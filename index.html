<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Godaigo - Hexagon Tile Game</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            background: #111;
            font-family: 'Courier New', monospace;
            color: #eee;
            user-select: none;
        }

        h1 {
            color: #d9b08c;
            text-shadow: 0 0 5px #b75000;
            text-align: center;
            margin-top: 0;
        }

        .game-container {
            display: flex;
            gap: 20px;
            max-width: 1400px;
        }

        .deck-panel {
            background: #222;
            padding: 20px;
            border-radius: 10px;
            width: 200px;
        }

        .deck-panel h3 {
            margin-top: 0;
            text-align: center;
            color: #d9b08c;
        }

        .tile-deck, .stone-deck {
            display: flex;
            flex-direction: column;
            gap: 15px;
            align-items: center;
        }

        .deck-tile {
            cursor: grab;
            transition: transform 0.2s;
        }

        .deck-tile:hover {
            transform: scale(1.05);
        }

        .deck-tile:active {
            cursor: grabbing;
        }

        .board-container {
            background: #222;
            border-radius: 10px;
            padding: 20px;
            position: relative;
            overflow: auto;
        }

        svg {
            display: block;
        }

        .hex-tile {
            fill: #d4a574;
            stroke: #2c3e50;
            stroke-width: 2;
        }

        .hex-tile.flipped {
            fill: #8b7355;
        }

        .hex-tile.empty-center {
            fill: none;
        }

        .placed-tile.player-tile .hex-tile {
            fill: #8b7355;
        }

        .placed-tile.player-tile .hex-tile.empty-center {
            fill: none;
        }

        .placed-tile {
            cursor: grab;
        }

        .placed-tile.has-stones {
            cursor: not-allowed;
        }

        .placed-tile:hover .hex-tile {
            stroke: #3498db;
            stroke-width: 4;
        }

        .ghost-tile {
            opacity: 0.4;
        }

        .shrine-marker {
            pointer-events: none;
        }

        .shrine-marker circle {
            filter: drop-shadow(0 0 3px rgba(255, 255, 255, 0.5));
        }

        .controls {
            background: #222;
            padding: 15px;
            border-radius: 8px;
            margin-top: 20px;
        }

        .player-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .action-points {
            background: #333;
            padding: 5px 10px;
            border-radius: 5px;
        }

        .stone-deck-item {
            cursor: grab;
            padding: 10px;
            background: #333;
            border-radius: 5px;
            text-align: center;
        }

        .stone-deck-item:hover {
            background: #444;
        }

        .stone-count {
            font-size: 12px;
            text-align: center;
            margin-top: 5px;
            font-weight: bold;
            color: #fff;
        }

        .source-count {
            font-size: 10px;
            text-align: center;
            margin-top: 2px;
            color: #999;
        }

        button {
            background: #b75000;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
        }

        button:hover {
            background: #d9b08c;
            color: #333;
        }

        #status {
            padding: 5px 10px;
            border-radius: 5px;
            background: #333;
            min-height: 20px;
            margin-top: 10px;
        }

        .snap-indicator {
            fill: none;
            stroke: #2ecc71;
            stroke-width: 4;
            opacity: 0;
            pointer-events: none;
        }

        .snap-indicator.active {
            opacity: 0.8;
        }

        .stone {
            cursor: grab;
            pointer-events: all;
            z-index: 100;
        }

        .stone:hover:not(.stone-ghost) .stone-piece {
            stroke-width: 3;
        }

        .stone:active {
            cursor: grabbing;
        }

        .stone-piece {
            stroke: #000;
            stroke-width: 2;
        }

        .stone-ghost {
            opacity: 0.5;
            transition: none;
            pointer-events: none;
        }

        .player {
            cursor: grab;
            pointer-events: all;
            z-index: 150;
        }

        .player:hover .player-marker {
            stroke-width: 3;
        }

        .player:active {
            cursor: grabbing;
        }

        .player-marker {
            /* fill color is set inline based on player color */
            stroke: #000;
            stroke-width: 2;
        }

        .teleport-indicator {
            cursor: pointer;
            pointer-events: all;
        }

        .teleport-indicator:hover {
            opacity: 0.8 !important;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 0.5; }
            50% { transform: scale(1.1); opacity: 0.7; }
        }
    </style>
</head>
<body>
    <h1>Godaigo - Hexagon Tile Game</h1>

    <div id="player-selection" style="background: #222; padding: 30px; border-radius: 10px; margin-bottom: 20px; text-align: center;">
        <h2 style="color: #d9b08c; margin-top: 0;">Select Number of Players</h2>
        <div style="display: flex; gap: 15px; justify-content: center; flex-wrap: wrap;">
            <button onclick="startGame(1)" style="padding: 15px 30px; font-size: 18px;">1 Player</button>
            <button onclick="startGame(2)" style="padding: 15px 30px; font-size: 18px;">2 Players</button>
            <button onclick="startGame(3)" style="padding: 15px 30px; font-size: 18px;">3 Players</button>
            <button onclick="startGame(4)" style="padding: 15px 30px; font-size: 18px;">4 Players</button>
            <button onclick="startGame(5)" style="padding: 15px 30px; font-size: 18px;">5 Players</button>
        </div>
        <p style="color: #999; margin-top: 15px; font-size: 14px;">
            1 player = 6 tiles (1 of each type)<br>
            Each additional player adds 6 more tiles in a spiral pattern
        </p>
    </div>

    <div class="game-container" style="display: none;">
        <div class="deck-panel">
            <h3>Tile Deck (<span id="deck-count">0/24</span>)</h3>
            <div class="tile-deck">
                <svg width="150" height="150" class="deck-tile" id="deckTile"></svg>
            </div>

            <h3 style="margin-top: 30px;">Player Tiles (<span id="player-tile-count">0</span>)</h3>
            <div class="tile-deck" id="player-tile-deck">
                <!-- Player tiles will be added here dynamically -->
            </div>

            <h3 style="margin-top: 30px;">Player Pool</h3>
            <div class="stone-deck">
                <div class="stone-deck-item" id="earth-deck">
                    <svg width="40" height="40">
                        <circle cx="20" cy="20" r="12" fill="#69d83a" class="stone-piece"/>
                        <text x="20" y="20" text-anchor="middle" dominant-baseline="middle" fill="#fff" font-size="14" font-weight="bold">‚ñ≤</text>
                    </svg>
                    <div class="stone-count" id="earth-count">0/5</div>
                    <div class="source-count" id="earth-source">20/25</div>
                </div>
                <div class="stone-deck-item" id="water-deck">
                    <svg width="40" height="40">
                        <circle cx="20" cy="20" r="12" fill="#5894f4" class="stone-piece"/>
                        <text x="20" y="20" text-anchor="middle" dominant-baseline="middle" fill="#fff" font-size="14" font-weight="bold">‚óØ</text>
                    </svg>
                    <div class="stone-count" id="water-count">0/5</div>
                    <div class="source-count" id="water-source">20/25</div>
                </div>
                <div class="stone-deck-item" id="fire-deck">
                    <svg width="40" height="40">
                        <circle cx="20" cy="20" r="12" fill="#ed1b43" class="stone-piece"/>
                        <text x="20" y="20" text-anchor="middle" dominant-baseline="middle" fill="#fff" font-size="14" font-weight="bold">‚ô¶</text>
                    </svg>
                    <div class="stone-count" id="fire-count">0/5</div>
                    <div class="source-count" id="fire-source">20/25</div>
                </div>
                <div class="stone-deck-item" id="wind-deck">
                    <svg width="40" height="40">
                        <circle cx="20" cy="20" r="12" fill="#ffce00" class="stone-piece"/>
                        <text x="20" y="20" text-anchor="middle" dominant-baseline="middle" fill="#fff" font-size="14" font-weight="bold">‚âã</text>
                    </svg>
                    <div class="stone-count" id="wind-count">0/5</div>
                    <div class="source-count" id="wind-source">20/25</div>
                </div>
                <div class="stone-deck-item" id="void-deck">
                    <svg width="40" height="40">
                        <circle cx="20" cy="20" r="12" fill="#9458f4" class="stone-piece"/>
                        <text x="20" y="20" text-anchor="middle" dominant-baseline="middle" fill="#fff" font-size="14" font-weight="bold">‚ú∫</text>
                    </svg>
                    <div class="stone-count" id="void-count">0/5</div>
                    <div class="source-count" id="void-source">20/25</div>
                </div>
            </div>
        </div>

        <div style="display: flex; flex-direction: column;">
            <div class="board-container">
                <svg id="boardSvg" width="1000" height="800">
                    <g id="viewport">
                        <circle class="snap-indicator" id="snapIndicator" r="10" cx="0" cy="0"/>
                    </g>
                </svg>
            </div>

            <div class="controls">
                <div class="player-info">
                    <div class="action-points">
                        AP: <span id="ap-count">5</span>/5
                        <span id="void-ap-display" style="color: #9458f4; margin-left: 10px;"></span>
                    </div>
                    <button id="end-turn">End Turn</button>
                    <button id="undo-move">Undo Move</button>
                    <button id="scroll-inventory">üìú Scrolls (<span id="scroll-count">0</span>)</button>
                    <button id="cast-spell">‚ú® Cast Spell (2 AP)</button>
                    <button onclick="clearBoard()">Clear Board</button>
                </div>

                <div id="status">Drag tiles from the deck to build your board. Drag stones onto hexes.<br>
                <small style="color: #999;">All stones: 1 AP baseline | üî• Fire destroys adjacent non-void | üíß Water (2 AP) chains abilities | üå™Ô∏è Wind free movement | üóª Earth blocks | ‚ú® Void nullifies</small></div>
            </div>
        </div>
    </div>

    <script>
        const TILE_SIZE = 20;
        const SNAP_THRESHOLD = 40;
        const STONE_SIZE = 12;

        const STONE_TYPES = {
            earth: { color: '#69d83a', symbol: '‚ñ≤' },
            water: { color: '#5894f4', symbol: '‚óØ' },
            fire: { color: '#ed1b43', symbol: '‚ô¶' },
            wind: { color: '#ffce00', symbol: '‚âã' },
            void: { color: '#9458f4', symbol: '‚ú∫' }
        };

        // Spell System for pattern-based stone generation
        class SpellSystem {
            constructor() {
                this.SPELL_AP_COST = 2;
                
                // Per-player scroll inventories
                this.playerScrolls = []; // Array of { collected: Set, activated: Set }
                
                // Shared available scrolls pool
                this.availableScrolls = {
                    earth: new Set(['EARTH_SCROLL_1', 'EARTH_SCROLL_2', 'EARTH_SCROLL_3', 'EARTH_SCROLL_4', 'EARTH_SCROLL_5']),
                    water: new Set(['WATER_SCROLL_1', 'WATER_SCROLL_2', 'WATER_SCROLL_3', 'WATER_SCROLL_4', 'WATER_SCROLL_5']),
                    fire: new Set(['FIRE_SCROLL_1', 'FIRE_SCROLL_2', 'FIRE_SCROLL_3', 'FIRE_SCROLL_4', 'FIRE_SCROLL_5']),
                    wind: new Set(['WIND_SCROLL_1', 'WIND_SCROLL_2', 'WIND_SCROLL_3', 'WIND_SCROLL_4', 'WIND_SCROLL_5']),
                    void: new Set(['VOID_SCROLL_1', 'VOID_SCROLL_2', 'VOID_SCROLL_3', 'VOID_SCROLL_4', 'VOID_SCROLL_5']),
                    catacomb: new Set(['CATACOMB_SCROLL_1', 'CATACOMB_SCROLL_2', 'CATACOMB_SCROLL_3', 'CATACOMB_SCROLL_4', 'CATACOMB_SCROLL_5', 'CATACOMB_SCROLL_6', 'CATACOMB_SCROLL_7', 'CATACOMB_SCROLL_8', 'CATACOMB_SCROLL_9', 'CATACOMB_SCROLL_10'])
                };
                
                this.initializePatterns();
                this.updateScrollCount();
            }
            
            // Get active player's scroll collection
            getPlayerScrolls() {
                if (!this.playerScrolls[activePlayerIndex]) {
                    this.playerScrolls[activePlayerIndex] = {
                        collected: new Set(),
                        activated: new Set()
                    };
                }
                return this.playerScrolls[activePlayerIndex];
            }
            
            // Compatibility getters for existing code
            get collectedScrolls() {
                return this.getPlayerScrolls().collected;
            }
            
            get activatedScrollTypes() {
                return this.getPlayerScrolls().activated;
            }

            initializePatterns() {
                // Corrected patterns from user's visual editor
                const level1Patterns = [
                    [{ q: 0, r: -1 }, { q: 0, r: 1 }],
                    [{ q: 1, r: -1 }, { q: -1, r: 1 }],
                    [{ q: 1, r: 0 }, { q: -1, r: 0 }]
                ];

                const level2Patterns = [
                    [{ q: -1, r: -1 }, { q: 1, r: 1 }],
                    [{ q: 1, r: -2 }, { q: -1, r: 2 }],
                    [{ q: 2, r: -1 }, { q: -2, r: 1 }]
                ];

                const level3Patterns = [
                    [{ q: 1, r: -1 }, { q: -1, r: 0 }, { q: 0, r: 1 }],
                    [{ q: 0, r: -1 }, { q: 1, r: 0 }, { q: -1, r: 1 }]
                ];

                const level4Patterns = [
                    [{ q: 1, r: -2 }, { q: -2, r: 1 }, { q: 1, r: 1 }],
                    [{ q: -1, r: -1 }, { q: 2, r: -1 }, { q: -1, r: 2 }]
                ];

                const level5Patterns = [
                    [{ q: 0, r: -1 }, { q: 0, r: 1 }, { q: 2, r: -1 }, { q: -2, r: 1 }],
                    [{ q: 1, r: -1 }, { q: -1, r: 1 }, { q: -1, r: -1 }, { q: 1, r: 1 }],
                    [{ q: 1, r: 0 }, { q: -1, r: 0 }, { q: 1, r: -2 }, { q: -1, r: 2 }]
                ];

                this.patterns = {};
                const elementTypes = ['earth', 'water', 'fire', 'wind', 'void'];
                
                elementTypes.forEach(element => {
                    [level1Patterns, level2Patterns, level3Patterns, level4Patterns, level5Patterns].forEach((patterns, level) => {
                        const scrollName = `${element.toUpperCase()}_SCROLL_${level + 1}`;
                        this.patterns[scrollName] = {
                            name: `${element.charAt(0).toUpperCase() + element.slice(1)} Scroll ${toRoman(level + 1)}`,
                            description: `Stand in pattern to gain +${level + 1} ${element} stones (2 AP)`,
                            level: level + 1,
                            element: element,
                            patterns: patterns.map(pattern => 
                                pattern.map(pos => ({ ...pos, type: element }))
                            )
                        };
                    });
                });
                
                // Add catacomb scrolls (multi-element patterns)
                // Each gets 3 rotational variations like level 2 scrolls
                const catacombBase = {
                    CATACOMB_SCROLL_1: [
                        { q: -1, r: -1, type: "water" },
                        { q: 1, r: 1, type: "water" },
                        { q: 1, r: -2, type: "earth" },
                        { q: -1, r: 2, type: "earth" }
                    ],
                    CATACOMB_SCROLL_2: [
                        { q: -1, r: -1, type: "earth" },
                        { q: 1, r: 1, type: "earth" },
                        { q: 1, r: -2, type: "fire" },
                        { q: -1, r: 2, type: "fire" }
                    ],
                    CATACOMB_SCROLL_3: [
                        { q: -1, r: -1, type: "wind" },
                        { q: 1, r: 1, type: "wind" },
                        { q: 1, r: -2, type: "earth" },
                        { q: -1, r: 2, type: "earth" }
                    ],
                    CATACOMB_SCROLL_4: [
                        { q: -1, r: -1, type: "void" },
                        { q: 1, r: 1, type: "void" },
                        { q: 1, r: -2, type: "earth" },
                        { q: -1, r: 2, type: "earth" }
                    ],
                    CATACOMB_SCROLL_5: [
                        { q: -1, r: -1, type: "water" },
                        { q: 1, r: 1, type: "water" },
                        { q: 1, r: -2, type: "fire" },
                        { q: -1, r: 2, type: "fire" }
                    ],
                    CATACOMB_SCROLL_6: [
                        { q: -1, r: -1, type: "wind" },
                        { q: 1, r: 1, type: "wind" },
                        { q: 1, r: -2, type: "water" },
                        { q: -1, r: 2, type: "water" }
                    ],
                    CATACOMB_SCROLL_7: [
                        { q: -1, r: -1, type: "void" },
                        { q: 1, r: 1, type: "void" },
                        { q: 1, r: -2, type: "water" },
                        { q: -1, r: 2, type: "water" }
                    ],
                    CATACOMB_SCROLL_8: [
                        { q: -1, r: -1, type: "fire" },
                        { q: 1, r: 1, type: "fire" },
                        { q: 1, r: -2, type: "wind" },
                        { q: -1, r: 2, type: "wind" }
                    ],
                    CATACOMB_SCROLL_9: [
                        { q: -1, r: -1, type: "void" },
                        { q: 1, r: 1, type: "void" },
                        { q: 1, r: -2, type: "wind" },
                        { q: -1, r: 2, type: "wind" }
                    ],
                    CATACOMB_SCROLL_10: [
                        { q: -1, r: -1, type: "fire" },
                        { q: 1, r: 1, type: "fire" },
                        { q: 1, r: -2, type: "void" },
                        { q: -1, r: 2, type: "void" }
                    ]
                };
                
                // Generate 3 rotational variations for each catacomb scroll
                Object.entries(catacombBase).forEach(([scrollName, basePattern]) => {
                    const scrollNum = parseInt(scrollName.split('_')[2]);
                    
                    // Helper function to rotate hex coordinate by 60 degrees
                    const rotateHex = (q, r, steps) => {
                        // Rotate counter-clockwise by steps * 60 degrees
                        let nq = q, nr = r;
                        for (let i = 0; i < steps; i++) {
                            const tempQ = nq;
                            nq = -nr;
                            nr = -(-tempQ - nr);
                        }
                        return { q: nq, r: nr };
                    };
                    
                    // Create 3 rotational variations (0¬∞, 120¬∞, 240¬∞)
                    const variations = [
                        basePattern, // 0¬∞ rotation
                        basePattern.map(pos => ({ // 120¬∞ rotation (2 steps)
                            ...rotateHex(pos.q, pos.r, 2),
                            type: pos.type
                        })),
                        basePattern.map(pos => ({ // 240¬∞ rotation (4 steps)
                            ...rotateHex(pos.q, pos.r, 4),
                            type: pos.type
                        }))
                    ];
                    
                    this.patterns[scrollName] = {
                        name: `Catacomb Scroll ${scrollNum}`,
                        description: `Multi-element pattern: gain +2 of each stone type (2 AP)`,
                        level: 2,
                        element: 'catacomb',
                        patterns: variations
                    };
                });
            }

            onTileRevealed(shrineType) {
                if (shrineType === 'player') return null;
                if (!this.availableScrolls[shrineType] || this.availableScrolls[shrineType].size === 0) {
                    return null;
                }

                const available = Array.from(this.availableScrolls[shrineType]);
                const selected = available[Math.floor(Math.random() * available.length)];
                
                this.availableScrolls[shrineType].delete(selected);
                this.collectedScrolls.add(selected);
                this.updateScrollCount();

                const scrollInfo = this.patterns[selected];
                this.showScrollNotification(scrollInfo, shrineType);
                return scrollInfo;
            }

            showScrollNotification(scrollInfo, elementType) {
                const notification = document.createElement('div');
                Object.assign(notification.style, {
                    position: 'fixed', left: '50%', top: '50%',
                    transform: 'translate(-50%, -50%)',
                    backgroundColor: '#2c3e50', padding: '30px',
                    borderRadius: '10px', boxShadow: '0 0 20px rgba(0,0,0,0.5)',
                    zIndex: '1000', color: 'white', textAlign: 'center',
                    minWidth: '400px', maxWidth: '600px'
                });

                const title = document.createElement('h2');
                title.textContent = 'üìú New Scroll Discovered!';
                title.style.color = STONE_TYPES[elementType].color;
                title.style.margin = '0 0 20px 0';
                notification.appendChild(title);

                const name = document.createElement('div');
                name.textContent = scrollInfo.name;
                name.style.fontSize = '24px';
                name.style.fontWeight = 'bold';
                name.style.marginBottom = '15px';
                notification.appendChild(name);

                const desc = document.createElement('div');
                desc.textContent = scrollInfo.description;
                desc.style.fontSize = '16px';
                desc.style.color = '#bdc3c7';
                desc.style.marginBottom = '20px';
                notification.appendChild(desc);

                const closeBtn = document.createElement('button');
                closeBtn.textContent = 'Got it!';
                closeBtn.onclick = () => document.body.removeChild(notification);
                notification.appendChild(closeBtn);

                document.body.appendChild(notification);
            }

            checkPattern(patternName) {
                const pattern = this.patterns[patternName];
                if (!pattern || !playerPosition) return false;

                const playerHex = pixelToHex(playerPosition.x, playerPosition.y, TILE_SIZE);
                
                console.log(`  Checking ${patternName}...`);

                return pattern.patterns.some((patternVariant, variantIdx) => {
                    const allMatch = patternVariant.every((req, reqIdx) => {
                        const checkHex = hexToPixel(playerHex.q + req.q, playerHex.r + req.r, TILE_SIZE);
                        const stone = placedStones.find(s => {
                            const dist = Math.sqrt(Math.pow(s.x - checkHex.x, 2) + Math.pow(s.y - checkHex.y, 2));
                            const matches = dist < 5 && s.type === req.type;
                            if (matches) {
                                console.log(`    ‚úì Found ${s.type} stone at (${req.q}, ${req.r})`);
                            }
                            return matches;
                        });
                        if (!stone) {
                            console.log(`    ‚úó Missing ${req.type} stone at (${req.q}, ${req.r})`);
                        }
                        return !!stone;
                    });
                    
                    if (allMatch) {
                        console.log(`    ‚úì‚úì‚úì PATTERN VARIANT ${variantIdx + 1} MATCHED!`);
                    }
                    return allMatch;
                });
            }

            castSpell() {
                if (!canAfford(this.SPELL_AP_COST)) {
                    updateStatus(`Not enough AP! Need ${this.SPELL_AP_COST} AP to cast.`);
                    return false;
                }

                // Debug: Log player position and nearby stones
                console.log('üîÆ Attempting to cast spell...');
                console.log(`Player position: (${playerPosition.x.toFixed(1)}, ${playerPosition.y.toFixed(1)})`);
                
                if (playerPosition) {
                    const playerHex = pixelToHex(playerPosition.x, playerPosition.y, TILE_SIZE);
                    console.log(`Player hex: q=${playerHex.q}, r=${playerHex.r}`);
                    
                    // Log nearby stones
                    console.log('Nearby stones:');
                    const nearbyStones = [];
                    placedStones.forEach(stone => {
                        const stoneHex = pixelToHex(stone.x, stone.y, TILE_SIZE);
                        const relQ = stoneHex.q - playerHex.q;
                        const relR = stoneHex.r - playerHex.r;
                        nearbyStones.push({ type: stone.type, q: relQ, r: relR });
                        console.log(`  ${stone.type} at relative (${relQ}, ${relR})`);
                    });
                    
                    // Check each collected scroll and show why it doesn't match
                    console.log('\nChecking collected scrolls:');
                    for (const scrollName of this.collectedScrolls) {
                        const pattern = this.patterns[scrollName];
                        console.log(`\n${scrollName} requires:`);
                        pattern.patterns.forEach((patternVariant, idx) => {
                            const coords = patternVariant.map(p => `(${p.q},${p.r}) ${p.type}`).join(' + ');
                            const matches = patternVariant.every(req => {
                                return nearbyStones.some(s => s.q === req.q && s.r === req.r && s.type === req.type);
                            });
                            console.log(`  Pattern ${idx + 1}: ${coords} - ${matches ? '‚úì MATCH' : '‚úó no match'}`);
                        });
                    }
                }

                const matchingSpells = [];
                for (const scrollName of this.collectedScrolls) {
                    if (this.checkPattern(scrollName)) {
                        console.log(`\n‚úì Pattern match found: ${scrollName}`);
                        matchingSpells.push({ name: scrollName, spell: this.patterns[scrollName] });
                    }
                }

                if (matchingSpells.length === 0) {
                    updateStatus("No valid spell pattern found! Check console for details.");
                    console.log('\n‚úó No matching patterns');
                    return false;
                }

                matchingSpells.sort((a, b) => b.spell.level - a.spell.level);

                if (matchingSpells.length > 1) {
                    this.showSpellSelection(matchingSpells);
                } else {
                    this.executeSpell(matchingSpells[0]);
                }
                return true;
            }

            showSpellSelection(spells) {
                const popup = document.createElement('div');
                Object.assign(popup.style, {
                    position: 'fixed', left: '50%', top: '50%',
                    transform: 'translate(-50%, -50%)',
                    backgroundColor: '#2c3e50', padding: '20px',
                    borderRadius: '10px', boxShadow: '0 0 10px rgba(0,0,0,0.5)',
                    zIndex: '1000', color: 'white', minWidth: '300px'
                });

                const title = document.createElement('h3');
                title.textContent = 'Select Scroll to Cast';
                title.style.textAlign = 'center';
                popup.appendChild(title);

                spells.forEach(({name, spell}) => {
                    const btn = document.createElement('button');
                    btn.textContent = `${spell.name} (+${spell.level} ${spell.element})`;
                    btn.style.width = '100%';
                    btn.style.marginBottom = '10px';
                    btn.onclick = () => {
                        document.body.removeChild(popup);
                        this.executeSpell({name, spell});
                    };
                    popup.appendChild(btn);
                });

                document.body.appendChild(popup);
            }

            executeSpell({name, spell}) {
                spendAP(this.SPELL_AP_COST); // Use void AP first, then regular AP

                if (spell.element === 'catacomb') {
                    // Catacomb scrolls give +2 of each element type in the pattern
                    const elementCounts = {};
                    spell.patterns[0].forEach(pos => {
                        elementCounts[pos.type] = (elementCounts[pos.type] || 0) + 1;
                    });
                    
                    const rewards = [];
                    Object.entries(elementCounts).forEach(([element, count]) => {
                        playerPool[element] = Math.min(
                            playerPoolCapacity[element],
                            playerPool[element] + count
                        );
                        updateStoneCount(element);
                        
                        // Track activated element for win condition
                        this.activatedScrollTypes.add(element);
                        rewards.push(`+${count} ${element}`);
                    });
                    
                    updatePlayerElementSymbols(activePlayerIndex);
                    updateStatus(`‚ú® Catacomb spell cast! Added ${rewards.join(', ')} stones!`);
                } else {
                    // Regular element scrolls
                    playerPool[spell.element] = Math.min(
                        playerPoolCapacity[spell.element],
                        playerPool[spell.element] + spell.level
                    );
                    updateStoneCount(spell.element);

                    this.activatedScrollTypes.add(spell.element);
                    updatePlayerElementSymbols(activePlayerIndex);
                    updateStatus(`‚ú® Spell cast! Added +${spell.level} ${spell.element} stones!`);
                }

                // Check if THIS player has won (activated all 5 elements)
                if (this.activatedScrollTypes.size === 5) {
                    this.showLevelComplete(activePlayerIndex);
                }
            }

            showLevelComplete(playerIndex) {
                const notification = document.createElement('div');
                Object.assign(notification.style, {
                    position: 'fixed', left: '50%', top: '50%',
                    transform: 'translate(-50%, -50%)',
                    backgroundColor: '#2c3e50', padding: '40px',
                    borderRadius: '15px', boxShadow: '0 0 30px rgba(0,0,0,0.8)',
                    zIndex: '1000', color: 'white', textAlign: 'center', minWidth: '500px',
                    border: '3px solid gold'
                });

                const title = document.createElement('h1');
                title.textContent = 'üéâ VICTORY! üéâ';
                title.style.marginTop = '0';
                title.style.color = 'gold';
                title.style.fontSize = '42px';
                title.style.textShadow = '2px 2px 4px rgba(0,0,0,0.5)';
                notification.appendChild(title);

                // Show which player won
                const playerColor = playerPositions[playerIndex]?.color;
                const colorNames = {
                    '#9458f4': 'Purple (Void)',
                    '#ffce00': 'Yellow (Wind)',
                    '#ed1b43': 'Red (Fire)',
                    '#5894f4': 'Blue (Water)',
                    '#69d83a': 'Green (Earth)'
                };
                
                const playerName = document.createElement('div');
                playerName.textContent = `${colorNames[playerColor] || 'Player ' + (playerIndex + 1)} wins!`;
                playerName.style.fontSize = '28px';
                playerName.style.fontWeight = 'bold';
                playerName.style.color = playerColor || 'gold';
                playerName.style.marginBottom = '10px';
                notification.appendChild(playerName);

                const msg = document.createElement('div');
                msg.textContent = 'You have mastered all five elements!';
                msg.style.fontSize = '24px';
                msg.style.marginBottom = '10px';
                notification.appendChild(msg);

                const elements = document.createElement('div');
                elements.style.fontSize = '32px';
                elements.style.margin = '20px 0';
                elements.innerHTML = '‚ñ≤ ‚óØ ‚ô¶ ‚âã ‚ú∫';
                notification.appendChild(elements);

                const subtitle = document.createElement('div');
                subtitle.textContent = 'The path of balance is complete.';
                subtitle.style.fontSize = '16px';
                subtitle.style.fontStyle = 'italic';
                subtitle.style.color = '#bdc3c7';
                subtitle.style.marginBottom = '20px';
                notification.appendChild(subtitle);

                const closeBtn = document.createElement('button');
                closeBtn.textContent = 'Continue Playing';
                closeBtn.style.padding = '12px 24px';
                closeBtn.style.fontSize = '16px';
                closeBtn.style.backgroundColor = 'gold';
                closeBtn.style.color = '#2c3e50';
                closeBtn.style.border = 'none';
                closeBtn.style.borderRadius = '5px';
                closeBtn.style.cursor = 'pointer';
                closeBtn.style.fontWeight = 'bold';
                closeBtn.onclick = () => document.body.removeChild(notification);
                notification.appendChild(closeBtn);

                document.body.appendChild(notification);
            }

            createPatternVisual(scroll, elementType) {
                const container = document.createElement('div');
                container.style.display = 'flex';
                container.style.justifyContent = 'center';
                container.style.alignItems = 'center';
                container.style.padding = '15px';
                container.style.backgroundColor = '#2c3e50';
                container.style.borderRadius = '5px';
                container.style.marginTop = '10px';
                container.style.position = 'relative';

                // Create SVG
                const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                svg.setAttribute('width', '200');
                svg.setAttribute('height', '200');
                svg.setAttribute('viewBox', '-100 -100 200 200');

                const hexSize = 15;

                // Helper to create hex points
                const createHexPoints = (cx, cy, size) => {
                    const points = [];
                    for (let i = 0; i < 6; i++) {
                        const angle = (Math.PI / 3) * i - Math.PI / 6;
                        points.push(`${cx + size * Math.cos(angle)},${cy + size * Math.sin(angle)}`);
                    }
                    return points.join(' ');
                };

                // Helper to convert axial to pixel
                const axialToPixel = (q, r) => {
                    const x = hexSize * (Math.sqrt(3) * q + Math.sqrt(3)/2 * r);
                    const y = hexSize * (3/2 * r);
                    return { x, y };
                };

                // Draw background hexes in a grid (static layer)
                const backgroundGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                for (let q = -2; q <= 2; q++) {
                    for (let r = -2; r <= 2; r++) {
                        if (Math.abs(q + r) <= 2) {
                            const pos = axialToPixel(q, r);
                            const hex = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                            hex.setAttribute('points', createHexPoints(pos.x, pos.y, hexSize));
                            hex.setAttribute('fill', '#34495e');
                            hex.setAttribute('stroke', '#2c3e50');
                            hex.setAttribute('stroke-width', '2');
                            backgroundGroup.appendChild(hex);
                        }
                    }
                }
                svg.appendChild(backgroundGroup);

                // Draw player hex (static layer)
                const playerHex = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                playerHex.setAttribute('cx', '0');
                playerHex.setAttribute('cy', '0');
                playerHex.setAttribute('r', hexSize * 0.5);
                playerHex.setAttribute('fill', '#fff');
                playerHex.setAttribute('stroke', '#333');
                playerHex.setAttribute('stroke-width', '2');
                svg.appendChild(playerHex);

                // Create pattern groups for each variation (animated layers)
                const patternGroups = [];
                scroll.patterns.forEach((patternVariation, idx) => {
                    const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                    group.style.opacity = idx === 0 ? '1' : '0';
                    group.style.transition = 'opacity 0.5s ease-in-out';

                    patternVariation.forEach(pos => {
                        const pixelPos = axialToPixel(pos.q, pos.r);
                        const stoneHex = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                        stoneHex.setAttribute('points', createHexPoints(pixelPos.x, pixelPos.y, hexSize));
                        // Use pos.type if available (for catacomb multi-element), otherwise use elementType
                        const stoneType = pos.type || elementType;
                        stoneHex.setAttribute('fill', STONE_TYPES[stoneType].color);
                        stoneHex.setAttribute('stroke', '#fff');
                        stoneHex.setAttribute('stroke-width', '2');
                        group.appendChild(stoneHex);

                        // Add symbol
                        const symbol = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                        symbol.setAttribute('x', pixelPos.x);
                        symbol.setAttribute('y', pixelPos.y);
                        symbol.setAttribute('text-anchor', 'middle');
                        symbol.setAttribute('dominant-baseline', 'middle');
                        symbol.setAttribute('fill', '#fff');
                        symbol.setAttribute('font-size', '12');
                        symbol.setAttribute('font-weight', 'bold');
                        symbol.textContent = STONE_TYPES[stoneType].symbol;
                        group.appendChild(symbol);
                    });

                    patternGroups.push(group);
                    svg.appendChild(group);
                });

                // Add pattern indicator text
                const indicatorText = document.createElement('div');
                indicatorText.style.position = 'absolute';
                indicatorText.style.bottom = '5px';
                indicatorText.style.right = '10px';
                indicatorText.style.fontSize = '11px';
                indicatorText.style.color = '#95a5a6';
                indicatorText.style.fontStyle = 'italic';
                indicatorText.textContent = `Pattern 1/${patternGroups.length}`;
                container.appendChild(indicatorText);

                // Cycle through patterns
                let currentPatternIdx = 0;
                const cycleInterval = setInterval(() => {
                    // Fade out current
                    patternGroups[currentPatternIdx].style.opacity = '0';
                    
                    // Move to next
                    currentPatternIdx = (currentPatternIdx + 1) % patternGroups.length;
                    
                    // Fade in next
                    patternGroups[currentPatternIdx].style.opacity = '1';
                    
                    // Update indicator
                    indicatorText.textContent = `Pattern ${currentPatternIdx + 1}/${patternGroups.length}`;
                }, 2500); // Change pattern every 2.5 seconds

                // Store interval ID so we can clean it up if needed
                container.dataset.intervalId = cycleInterval;

                container.appendChild(svg);
                return container;
            }

            showInventory() {
                const popup = document.createElement('div');
                Object.assign(popup.style, {
                    position: 'fixed', left: '50%', top: '50%',
                    transform: 'translate(-50%, -50%)',
                    backgroundColor: '#2c3e50', padding: '20px',
                    borderRadius: '10px', boxShadow: '0 0 20px rgba(0,0,0,0.5)',
                    zIndex: '1001', minWidth: '400px', maxHeight: '80vh',
                    overflowY: 'auto', color: 'white'
                });

                const title = document.createElement('h2');
                title.textContent = 'üìú Scroll Collection';
                title.style.textAlign = 'center';
                title.style.color = '#3498db';
                popup.appendChild(title);

                const closeBtn = document.createElement('button');
                closeBtn.textContent = '√ó';
                Object.assign(closeBtn.style, {
                    position: 'absolute', right: '10px', top: '10px',
                    background: 'transparent', border: 'none',
                    color: 'white', fontSize: '24px', cursor: 'pointer'
                });
                closeBtn.onclick = () => document.body.removeChild(popup);
                popup.appendChild(closeBtn);

                const elementTypes = ['earth', 'water', 'fire', 'wind', 'void'];
                elementTypes.forEach(element => {
                    const scrolls = Array.from(this.collectedScrolls)
                        .filter(s => s.startsWith(element.toUpperCase()))
                        .map(s => this.patterns[s]);

                    if (scrolls.length > 0) {
                        const section = document.createElement('div');
                        section.style.marginBottom = '20px';

                        const header = document.createElement('h3');
                        header.textContent = `${STONE_TYPES[element].symbol} ${element.charAt(0).toUpperCase() + element.slice(1)} Scrolls`;
                        header.style.color = STONE_TYPES[element].color;
                        header.style.borderBottom = `2px solid ${STONE_TYPES[element].color}`;
                        section.appendChild(header);

                        scrolls.forEach(scroll => {
                            const scrollDiv = document.createElement('div');
                            scrollDiv.style.backgroundColor = '#34495e';
                            scrollDiv.style.padding = '15px';
                            scrollDiv.style.marginBottom = '10px';
                            scrollDiv.style.borderRadius = '5px';

                            const scrollName = document.createElement('div');
                            scrollName.textContent = scroll.name;
                            scrollName.style.fontWeight = 'bold';
                            scrollName.style.marginBottom = '5px';
                            scrollDiv.appendChild(scrollName);

                            const scrollDesc = document.createElement('div');
                            scrollDesc.textContent = scroll.description;
                            scrollDesc.style.fontSize = '14px';
                            scrollDesc.style.color = '#bdc3c7';
                            scrollDesc.style.marginBottom = '10px';
                            scrollDiv.appendChild(scrollDesc);

                            // Add visual hex pattern display
                            const patternVisual = this.createPatternVisual(scroll, element);
                            scrollDiv.appendChild(patternVisual);

                            // Add pattern visualization
                            const patternInfo = document.createElement('div');
                            patternInfo.style.fontSize = '12px';
                            patternInfo.style.color = '#95a5a6';
                            patternInfo.style.fontFamily = 'monospace';
                            patternInfo.style.backgroundColor = '#2c3e50';
                            patternInfo.style.padding = '10px';
                            patternInfo.style.borderRadius = '5px';
                            patternInfo.style.marginTop = '10px';
                            
                            const patternTitle = document.createElement('div');
                            patternTitle.textContent = 'Required Pattern (one of these):';
                            patternTitle.style.marginBottom = '5px';
                            patternInfo.appendChild(patternTitle);
                            
                            // Show first 3 pattern variations
                            scroll.patterns.slice(0, 3).forEach((pattern, idx) => {
                                const patternLine = document.createElement('div');
                                const coords = pattern.map(pos => `(${pos.q},${pos.r})`).join(' + ');
                                patternLine.textContent = `${idx + 1}. Stones at: ${coords}`;
                                patternLine.style.marginLeft = '10px';
                                patternLine.style.marginTop = '3px';
                                patternInfo.appendChild(patternLine);
                            });
                            
                            if (scroll.patterns.length > 3) {
                                const moreText = document.createElement('div');
                                moreText.textContent = `... and ${scroll.patterns.length - 3} more rotations`;
                                moreText.style.marginLeft = '10px';
                                moreText.style.marginTop = '3px';
                                moreText.style.fontStyle = 'italic';
                                patternInfo.appendChild(moreText);
                            }
                            
                            scrollDiv.appendChild(patternInfo);

                            section.appendChild(scrollDiv);
                        });

                        popup.appendChild(section);
                    }
                });

                // Add catacomb scrolls section
                const catacombScrolls = Array.from(this.collectedScrolls)
                    .filter(s => s.startsWith('CATACOMB'))
                    .map(s => this.patterns[s]);

                if (catacombScrolls.length > 0) {
                    const section = document.createElement('div');
                    section.style.marginBottom = '20px';

                    const header = document.createElement('h3');
                    header.textContent = '‚ö∞Ô∏è Catacomb Scrolls (Multi-Element)';
                    header.style.color = '#9b59b6';
                    header.style.borderBottom = '2px solid #9b59b6';
                    section.appendChild(header);

                    catacombScrolls.forEach(scroll => {
                        const scrollDiv = document.createElement('div');
                        scrollDiv.style.backgroundColor = '#34495e';
                        scrollDiv.style.padding = '15px';
                        scrollDiv.style.marginBottom = '10px';
                        scrollDiv.style.borderRadius = '5px';

                        const scrollName = document.createElement('div');
                        scrollName.textContent = scroll.name;
                        scrollName.style.fontWeight = 'bold';
                        scrollName.style.marginBottom = '5px';
                        scrollDiv.appendChild(scrollName);

                        const scrollDesc = document.createElement('div');
                        scrollDesc.textContent = scroll.description;
                        scrollDesc.style.fontSize = '14px';
                        scrollDesc.style.color = '#bdc3c7';
                        scrollDesc.style.marginBottom = '10px';
                        scrollDiv.appendChild(scrollDesc);

                        // Add visual hex pattern display (catacomb uses 'catacomb' as element type)
                        const patternVisual = this.createPatternVisual(scroll, 'catacomb');
                        scrollDiv.appendChild(patternVisual);

                        // Add pattern visualization
                        const patternInfo = document.createElement('div');
                        patternInfo.style.fontSize = '12px';
                        patternInfo.style.color = '#95a5a6';
                        patternInfo.style.fontFamily = 'monospace';
                        patternInfo.style.backgroundColor = '#2c3e50';
                        patternInfo.style.padding = '10px';
                        patternInfo.style.borderRadius = '5px';
                        patternInfo.style.marginTop = '10px';
                        
                        const patternTitle = document.createElement('div');
                        patternTitle.textContent = 'Required Pattern (one of these):';
                        patternTitle.style.marginBottom = '5px';
                        patternInfo.appendChild(patternTitle);
                        
                        // Show all 3 pattern variations
                        scroll.patterns.forEach((pattern, idx) => {
                            const patternLine = document.createElement('div');
                            const coords = pattern.map(pos => `${pos.type.charAt(0).toUpperCase()}(${pos.q},${pos.r})`).join(' + ');
                            patternLine.textContent = `${idx + 1}. Stones at: ${coords}`;
                            patternLine.style.marginLeft = '10px';
                            patternLine.style.marginTop = '3px';
                            patternInfo.appendChild(patternLine);
                        });
                        
                        scrollDiv.appendChild(patternInfo);
                        section.appendChild(scrollDiv);
                    });

                    popup.appendChild(section);
                }

                if (this.collectedScrolls.size === 0) {
                    const noScrolls = document.createElement('div');
                    noScrolls.textContent = 'No scrolls collected yet. Reveal tiles to find scrolls!';
                    noScrolls.style.textAlign = 'center';
                    noScrolls.style.color = '#bdc3c7';
                    noScrolls.style.padding = '20px';
                    popup.appendChild(noScrolls);
                }

                document.body.appendChild(popup);
            }

            updateScrollCount() {
                document.getElementById('scroll-count').textContent = this.collectedScrolls.size;
            }
        }

        function toRoman(num) {
            const map = { 1: 'I', 2: 'II', 3: 'III', 4: 'IV', 5: 'V' };
            return map[num] || num;
        }

        // Core game state - declare these FIRST
        let placedTiles = [];
        let placedStones = [];
        let playerPositions = []; // Array of {x, y, element, color} for each player
        let activePlayerIndex = 0; // Which player is currently active
        
        // Player pools - one per player
        let playerPools = []; // Each entry is { earth: 0, water: 0, fire: 0, wind: 0, void: 0 }
        const playerPoolCapacity = { earth: 5, water: 5, fire: 5, wind: 5, void: 5 };

        // Elemental source pool - stones available from shrines (max 25 each)
        const sourcePool = { earth: 20, water: 20, fire: 20, wind: 20, void: 20 };
        const sourcePoolCapacity = { earth: 25, water: 25, fire: 25, wind: 25, void: 25 };

        // Initialize spell system (after activePlayerIndex is defined)
        const spellSystem = new SpellSystem();

        // Compatibility: playerPool and stoneCounts refer to active player's pool
        Object.defineProperty(window, 'playerPool', {
            get() { 
                if (!playerPools[activePlayerIndex]) {
                    playerPools[activePlayerIndex] = { earth: 0, water: 0, fire: 0, wind: 0, void: 0 };
                }
                return playerPools[activePlayerIndex];
            }
        });
        Object.defineProperty(window, 'stoneCounts', {
            get() { 
                if (!playerPools[activePlayerIndex]) {
                    playerPools[activePlayerIndex] = { earth: 0, water: 0, fire: 0, wind: 0, void: 0 };
                }
                return playerPools[activePlayerIndex];
            }
        });
        const stoneCapacity = playerPoolCapacity;

        const boardSvg = document.getElementById('boardSvg');
        const viewport = document.getElementById('viewport');
        const deckTileSvg = document.getElementById('deckTile');
        const snapIndicator = document.getElementById('snapIndicator');
        
        // Compatibility: make playerPosition work as before for active player
        Object.defineProperty(window, 'playerPosition', {
            get() { return playerPositions[activePlayerIndex] || null; },
            set(val) { 
                if (val === null) {
                    playerPositions = [];
                    activePlayerIndex = 0;
                }
            }
        });
        
        let playerColor = null; // Current player's color (when placing their tile)
        let gameSessionColors = new Set(); // Colors used in the current game
        let currentAP = 5;
        let voidAP = 0; // Bonus AP from void stones (used first)
        let lastMove = null; // Stores { prevPos: {x, y}, newPos: {x, y}, apCost: number }

        const PLAYER_COLORS = {
            green: '#69d83a',
            blue: '#5894f4', 
            red: '#ed1b43',
            yellow: '#ffce00',
            purple: '#9458f4'
        };

        function updateVoidAP() {
            // Void AP always equals current void stones
            const oldVoidAP = voidAP;
            voidAP = playerPool.void;
            console.log(`üîÑ updateVoidAP: ${oldVoidAP} ‚Üí ${voidAP} (playerPool.void=${playerPool.void})`);
            const display = document.getElementById('void-ap-display');
            if (voidAP > 0) {
                display.textContent = `(+${voidAP} ‚ú® Void AP)`;
                display.style.display = 'inline';
            } else {
                display.style.display = 'none';
            }
        }

        function getTotalAP() {
            return currentAP + voidAP;
        }

        function spendAP(cost) {
            console.log(`üí∞ spendAP called: cost=${cost}, before: voidAP=${voidAP}, currentAP=${currentAP}`);
            // Spend void AP first, then regular AP
            if (voidAP >= cost) {
                voidAP -= cost;
            } else {
                const remainingCost = cost - voidAP;
                voidAP = 0;
                currentAP -= remainingCost;
            }
            console.log(`üí∞ spendAP after: voidAP=${voidAP}, currentAP=${currentAP}, total=${getTotalAP()}`);
            document.getElementById('ap-count').textContent = currentAP;
            updateVoidAP();
        }

        function canAfford(cost) {
            return getTotalAP() >= cost;
        }

        function attemptBreakStone(stoneId) {
            const stone = placedStones.find(s => s.id === stoneId);
            if (!stone) {
                console.log('‚ùå Stone not found');
                return;
            }

            console.log(`üí• attemptBreakStone called for stone id=${stoneId}, type=${stone.type}, position=(${stone.x.toFixed(1)}, ${stone.y.toFixed(1)})`);

            // Check if stone is adjacent to player
            if (!playerPosition) {
                updateStatus('‚ùå No player on board!');
                console.log('‚ùå No player on board!');
                return;
            }

            const isAdj = isAdjacentToPlayer(stone.x, stone.y);
            console.log(`üí• Adjacency check: ${isAdj}`);
            
            if (!isAdj) {
                updateStatus('‚ùå Stone must be adjacent to player to break!');
                console.log('‚ùå Stone must be adjacent to player to break!');
                return;
            }

            // Calculate break cost based on stone rank
            const STONE_RANK = {
                'void': 1,
                'wind': 2,
                'fire': 3,
                'water': 4,
                'earth': 5
            };

            const breakCost = STONE_RANK[stone.type];

            if (!canAfford(breakCost)) {
                updateStatus(`‚ùå Not enough AP! Need ${breakCost} AP to break ${stone.type} stone (have ${getTotalAP()} AP)`);
                return;
            }

            // Break the stone
            spendAP(breakCost);
            
            // Remove stone from board
            const stoneElement = stone.element;
            if (stoneElement && stoneElement.parentNode) {
                stoneElement.remove();
            }

            // Remove from placedStones array
            const index = placedStones.findIndex(s => s.id === stoneId);
            if (index !== -1) {
                placedStones.splice(index, 1);
            }

            // Return stone to source pool
            returnStoneToPool(stone.type);

            // Update interactions since a stone was removed
            updateTileClasses();
            recheckAllStoneInteractions();
            updateAllWaterStoneVisuals();
            updateAllVoidNullificationVisuals();

            updateStatus(`üí• Broke ${stone.type} stone! Cost: ${breakCost} AP (${getTotalAP()} AP remaining)`);
            console.log(`üí• Broke ${stone.type} stone (id=${stoneId}), cost=${breakCost} AP`);
        }

        let isDraggingTile = false;
        let isDraggingStone = false;
        let draggedTileId = null;
        let draggedTileRotation = 0;
        let draggedTileFlipped = false;
        let draggedTileShrineType = null;
        let draggedTileOriginalPos = null; // Store original position for snap-back
        let draggedStoneId = null;
        let draggedStoneType = null;
        let ghostTile = null;
        let ghostStone = null;
        let currentRotation = 0;
        let currentFlipped = true; // Start with tiles hidden (flipped)


        // Tile deck - 4 of each shrine type (24 tiles total for 1 player)
        let tileDeck = [];
        let deckIndex = 0;

        // Player tile deck
        let playerTilesAvailable = 0;
        let playerTileElements = [];

        function initializeDeck(numPlayers = 1) {
            const shrineTypes = ['earth', 'water', 'fire', 'wind', 'void', 'catacomb'];
            const tilesPerType = numPlayers; // 1 of each type per player

            tileDeck = [];

            shrineTypes.forEach(type => {
                for (let i = 0; i < tilesPerType; i++) {
                    tileDeck.push(type);
                }
            });

            // Shuffle the deck
            for (let i = tileDeck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [tileDeck[i], tileDeck[j]] = [tileDeck[j], tileDeck[i]];
            }

            deckIndex = 0;
        }

        function drawNextTileFromDeck() {
            if (deckIndex >= tileDeck.length) {
                updateStatus('No more tiles in deck!');
                return null;
            }
            const shrineType = tileDeck[deckIndex];
            deckIndex++;
            document.getElementById('deck-count').textContent = `${deckIndex}/${tileDeck.length}`;
            updateStatus(`Drew ${shrineType} tile (${deckIndex}/${tileDeck.length} used)`);
            return shrineType;
        }

        let viewportX = 0;
        let viewportY = 0;
        let viewportScale = 1;
        let viewportRotation = 0;
        let isPanning = false;
        let panStartX = 0;
        let panStartY = 0;
        let lastPanX = 0;
        let lastPanY = 0;
        let isRotatingBoard = false;
        let rotateStartX = 0;
        let rotateStartRotation = 0;
        let isRotatingTile = false;
        let rotateTileStartX = 0;
        let rotateTileStartRotation = 0;
        let leftButtonDown = false;
        let rightButtonDown = false;

        function updateViewport() {
            const centerX = boardSvg.width.baseVal.value / 2;
            const centerY = boardSvg.height.baseVal.value / 2;
            viewport.setAttribute('transform',
                `translate(${centerX}, ${centerY}) rotate(${viewportRotation}) translate(${viewportX - centerX}, ${viewportY - centerY}) scale(${viewportScale})`);
        }

        function screenToWorld(screenX, screenY) {
            const centerX = boardSvg.width.baseVal.value / 2;
            const centerY = boardSvg.height.baseVal.value / 2;
            let x = screenX - centerX;
            let y = screenY - centerY;
            const rad = -viewportRotation * Math.PI / 180;
            const cos = Math.cos(rad);
            const sin = Math.sin(rad);
            const rotatedX = x * cos - y * sin;
            const rotatedY = x * sin + y * cos;
            const scaledX = rotatedX / viewportScale;
            const scaledY = rotatedY / viewportScale;
            const worldX = scaledX - (viewportX - centerX) / viewportScale;
            const worldY = scaledY - (viewportY - centerY) / viewportScale;
            return { x: worldX, y: worldY };
        }

        function hexToPixel(q, r, s) {
            const width = s * Math.sqrt(3);
            const height = 2 * s;
            const x = width * (q + r / 2);
            const y = height * (3/4) * r;
            return { x, y };
        }

        function pixelToHex(x, y, s) {
            const q = (x * Math.sqrt(3)/3 - y / 3) / s;
            const r = (y * 2/3) / s;
            return hexRound(q, r);
        }

        function hexRound(q, r) {
            let s = -q - r;
            let rq = Math.round(q);
            let rr = Math.round(r);
            let rs = Math.round(s);
            const qDiff = Math.abs(rq - q);
            const rDiff = Math.abs(rr - r);
            const sDiff = Math.abs(rs - s);
            if (qDiff > rDiff && qDiff > sDiff) rq = -rr - rs;
            else if (rDiff > sDiff) rr = -rq - rs;
            return { q: rq, r: rr };
        }

        function createHexagonPoints(cx, cy, s) {
            const points = [];
            for (let i = 0; i < 6; i++) {
                const angle = (Math.PI / 3) * i - Math.PI / 6;
                const x = cx + s * Math.cos(angle);
                const y = cy + s * Math.sin(angle);
                points.push(`${x},${y}`);
            }
            return points.join(' ');
        }

        function createTrapezoidPoints(cx, cy, s, direction) {
            const hexVertices = [];
            for (let i = 0; i < 6; i++) {
                const angle = (Math.PI / 3) * i - Math.PI / 6;
                hexVertices.push({
                    x: cx + s * Math.cos(angle),
                    y: cy + s * Math.sin(angle)
                });
            }
            const indices = [
                [1, 2, 3, 4], [2, 3, 4, 5], [3, 4, 5, 0],
                [4, 5, 0, 1], [5, 0, 1, 2], [0, 1, 2, 3]
            ][direction];
            return indices.map(idx => `${hexVertices[idx].x},${hexVertices[idx].y}`).join(' ');
        }

        function createTileGroup(s, rotation = 0, flipped = false) {
            const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            g.setAttribute('transform', `rotate(${rotation * 60})`);

            if (flipped) {
                // Flipped side: only outer ring of hexagons + trapezoids (no center, no inner ring)
                const hexagons = [
                    { q: 2, r: -1 }, { q: 1, r: 1 }, { q: -1, r: 2 },
                    { q: -2, r: 1 }, { q: -1, r: -1 }, { q: 1, r: -2 }
                ];

                hexagons.forEach(hex => {
                    const pos = hexToPixel(hex.q, hex.r, s);
                    const points = createHexagonPoints(pos.x, pos.y, s);
                    const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                    polygon.setAttribute('points', points);
                    polygon.setAttribute('class', 'hex-tile flipped');
                    g.appendChild(polygon);
                });

                const trapezoids = [
                    { q: 2, r: 0, dir: 1 }, { q: 0, r: 2, dir: 2 },
                    { q: -2, r: 2, dir: 3 }, { q: -2, r: 0, dir: 4 },
                    { q: 0, r: -2, dir: 5 }, { q: 2, r: -2, dir: 0 }
                ];

                trapezoids.forEach(trap => {
                    const pos = hexToPixel(trap.q, trap.r, s);
                    const points = createTrapezoidPoints(pos.x, pos.y, s, trap.dir);
                    const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                    polygon.setAttribute('points', points);
                    polygon.setAttribute('class', 'hex-tile trapezoid flipped');
                    g.appendChild(polygon);
                });

                // Add empty center hex for visual reference (no fill)
                const centerPos = hexToPixel(0, 0, s);
                const centerPoints = createHexagonPoints(centerPos.x, centerPos.y, s);
                const centerPolygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                centerPolygon.setAttribute('points', centerPoints);
                centerPolygon.setAttribute('class', 'hex-tile empty-center');
                g.appendChild(centerPolygon);
            } else {
                // Normal side: all hexagons
                const hexagons = [
                    { q: 0, r: 0, class: 'center-hex' },
                    { q: 1, r: 0 }, { q: 0, r: 1 }, { q: -1, r: 1 },
                    { q: -1, r: 0 }, { q: 0, r: -1 }, { q: 1, r: -1 },
                    { q: 2, r: -1 }, { q: 1, r: 1 }, { q: -1, r: 2 },
                    { q: -2, r: 1 }, { q: -1, r: -1 }, { q: 1, r: -2 }
                ];

                hexagons.forEach(hex => {
                    const pos = hexToPixel(hex.q, hex.r, s);
                    const points = createHexagonPoints(pos.x, pos.y, s);
                    const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                    polygon.setAttribute('points', points);
                    polygon.setAttribute('class', `hex-tile ${hex.class || ''}`);
                    g.appendChild(polygon);
                });

                const trapezoids = [
                    { q: 2, r: 0, dir: 1 }, { q: 0, r: 2, dir: 2 },
                    { q: -2, r: 2, dir: 3 }, { q: -2, r: 0, dir: 4 },
                    { q: 0, r: -2, dir: 5 }, { q: 2, r: -2, dir: 0 }
                ];

                trapezoids.forEach(trap => {
                    const pos = hexToPixel(trap.q, trap.r, s);
                    const points = createTrapezoidPoints(pos.x, pos.y, s, trap.dir);
                    const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                    polygon.setAttribute('points', points);
                    polygon.setAttribute('class', 'hex-tile trapezoid');
                    g.appendChild(polygon);
                });
            }

            return g;
        }

        function drawDeckTile() {
            deckTileSvg.innerHTML = '';
            const tile = createTileGroup(6, currentRotation, currentFlipped);
            tile.setAttribute('transform', 'translate(75, 75)');
            deckTileSvg.appendChild(tile);
        }

        function initializePlayerTiles(numPlayers) {
            const playerTileDeck = document.getElementById('player-tile-deck');
            playerTileDeck.innerHTML = '';
            playerTileElements = [];
            playerTilesAvailable = numPlayers;
            document.getElementById('player-tile-count').textContent = numPlayers;

            for (let i = 0; i < numPlayers; i++) {
                const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                svg.setAttribute('width', '150');
                svg.setAttribute('height', '150');
                svg.setAttribute('class', 'deck-tile player-tile-deck-item');
                svg.setAttribute('data-player-index', i);

                const tile = createTileGroup(6, 0, false); // Player tiles are not flipped
                tile.setAttribute('transform', 'translate(75, 75)');
                svg.appendChild(tile);

                playerTileDeck.appendChild(svg);
                playerTileElements.push(svg);

                // Add mousedown event for dragging
                svg.addEventListener('mousedown', (e) => {
                    if (playerTilesAvailable <= 0) return;
                    if (e.button === 0) {
                        startPlayerTileDrag(i, e);
                    }
                });
            }
        }

        function startPlayerTileDrag(playerIndex, e) {
            isDraggingTile = true;
            draggedTileId = null;
            draggedTileRotation = 0;
            draggedTileFlipped = false;
            draggedTileShrineType = 'player'; // Mark as player tile
            draggedTileOriginalPos = null;

            const rect = boardSvg.getBoundingClientRect();
            const screenX = e.clientX - rect.left;
            const screenY = e.clientY - rect.top;
            const world = screenToWorld(screenX, screenY);

            ghostTile = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            ghostTile.setAttribute('class', 'ghost-tile');
            ghostTile.setAttribute('transform', `translate(${world.x}, ${world.y})`);
            const tile = createTileGroup(TILE_SIZE, 0, false);
            ghostTile.appendChild(tile);
            viewport.appendChild(ghostTile);
        }

        function getAllHexagonPositions() {
            const positions = new Map();
            const trapezoidMap = new Map();

            placedTiles.forEach(tile => {
                const s = TILE_SIZE;

                // For flipped tiles, only include outer ring hexagons
                // For normal tiles and player tiles, include all hexagons
                // Player tiles look revealed but allow walking off them
                let hexagons;
                if (tile.flipped && !tile.isPlayerTile) {
                    hexagons = [
                        { q: 2, r: -1 }, { q: 1, r: 1 }, { q: -1, r: 2 },
                        { q: -2, r: 1 }, { q: -1, r: -1 }, { q: 1, r: -2 }
                    ];
                } else {
                    hexagons = [
                        { q: 0, r: 0 },
                        { q: 1, r: 0 }, { q: 0, r: 1 }, { q: -1, r: 1 },
                        { q: -1, r: 0 }, { q: 0, r: -1 }, { q: 1, r: -1 },
                        { q: 2, r: -1 }, { q: 1, r: 1 }, { q: -1, r: 2 },
                        { q: -2, r: 1 }, { q: -1, r: -1 }, { q: 1, r: -2 }
                    ];
                }

                hexagons.forEach(hex => {
                    const localPos = hexToPixel(hex.q, hex.r, s);
                    const globalX = tile.x + localPos.x;
                    const globalY = tile.y + localPos.y;
                    const roundedX = Math.round(globalX * 100) / 100;
                    const roundedY = Math.round(globalY * 100) / 100;
                    const key = `${roundedX},${roundedY}`;
                    if (!positions.has(key)) {
                        positions.set(key, { x: globalX, y: globalY, key, tiles: [tile] });
                    } else {
                        // Track which tiles contribute to this position
                        const existing = positions.get(key);
                        if (!existing.tiles.includes(tile)) {
                            existing.tiles.push(tile);
                        }
                    }
                });

                const trapezoids = [
                    { q: 2, r: 0 }, { q: 0, r: 2 }, { q: -2, r: 2 },
                    { q: -2, r: 0 }, { q: 0, r: -2 }, { q: 2, r: -2 }
                ];

                trapezoids.forEach(trap => {
                    const localPos = hexToPixel(trap.q, trap.r, s);
                    const globalX = tile.x + localPos.x;
                    const globalY = tile.y + localPos.y;
                    const roundedX = Math.round(globalX * 100) / 100;
                    const roundedY = Math.round(globalY * 100) / 100;
                    const key = `${roundedX},${roundedY}`;
                    if (!trapezoidMap.has(key)) {
                        trapezoidMap.set(key, { count: 1, x: globalX, y: globalY, key, tiles: [tile] });
                    } else {
                        const existing = trapezoidMap.get(key);
                        existing.count += 1;
                        if (!existing.tiles.includes(tile)) {
                            existing.tiles.push(tile);
                        }
                        if (existing.count >= 2 && !positions.has(key)) {
                            positions.set(key, { x: globalX, y: globalY, key, tiles: existing.tiles });
                        }
                    }
                });
            });

            return Array.from(positions.values());
        }

        function isPositionOnFlippedTile(x, y, hexPositions) {
            // Find the hex position that matches this x,y
            const matchingPos = hexPositions.find(pos => {
                const dist = Math.sqrt(Math.pow(pos.x - x, 2) + Math.pow(pos.y - y, 2));
                return dist < 5;
            });

            if (!matchingPos || !matchingPos.tiles) return false;

            // Check if ANY of the tiles contributing to this position are flipped (and not player tile)
            return matchingPos.tiles.some(tile => tile.flipped && !tile.isPlayerTile);
        }

        function findValidStonePosition(x, y) {
            const hexPositions = getAllHexagonPositions();
            let nearest = null;
            let minDist = Infinity;

            hexPositions.forEach(pos => {
                const dist = Math.sqrt(Math.pow(x - pos.x, 2) + Math.pow(y - pos.y, 2));
                if (dist < minDist) {
                    minDist = dist;
                    nearest = pos;
                }
            });

            if (nearest && minDist < TILE_SIZE * 2) {
                const occupied = placedStones.some(stone => {
                    const dist = Math.sqrt(Math.pow(stone.x - nearest.x, 2) + Math.pow(stone.y - nearest.y, 2));
                    return dist < 5;
                });

                const playerHere = playerPosition && Math.sqrt(Math.pow(playerPosition.x - nearest.x, 2) + Math.pow(playerPosition.y - nearest.y, 2)) < 5;

                const onFlippedTile = isPositionOnFlippedTile(nearest.x, nearest.y, hexPositions);

                // NEW: Check if position is adjacent to player
                const adjacentToPlayer = playerPosition && isAdjacentToPlayer(nearest.x, nearest.y);

                if (!occupied && !playerHere && !onFlippedTile && adjacentToPlayer) {
                    return { x: nearest.x, y: nearest.y, valid: true };
                }
            }

            return { x: x, y: y, valid: false };
        }

        function isAdjacentToPlayer(x, y) {
            if (!playerPosition) return false;
            
            // Get hex coordinates for both positions
            const playerHex = pixelToHex(playerPosition.x, playerPosition.y, TILE_SIZE);
            const targetHex = pixelToHex(x, y, TILE_SIZE);
            
            // Calculate axial distance
            const dq = Math.abs(playerHex.q - targetHex.q);
            const dr = Math.abs(playerHex.r - targetHex.r);
            const ds = Math.abs((-playerHex.q - playerHex.r) - (-targetHex.q - targetHex.r));
            
            // Adjacent means distance = 1 in hex coordinates
            const hexDistance = Math.max(dq, dr, ds);
            
            const isAdj = hexDistance === 1;
            console.log(`üîç isAdjacentToPlayer: player=(${playerHex.q},${playerHex.r}), target=(${targetHex.q},${targetHex.r}), distance=${hexDistance}, adjacent=${isAdj}`);
            
            return isAdj;
        }

        function findNearestHexPosition(x, y) {
            // Similar to findValidStonePosition, but doesn't care about stones/player
            // Used for player movement pathfinding
            const hexPositions = getAllHexagonPositions();
            let nearest = null;
            let minDist = Infinity;

            hexPositions.forEach(pos => {
                const dist = Math.sqrt(Math.pow(x - pos.x, 2) + Math.pow(y - pos.y, 2));
                if (dist < minDist) {
                    minDist = dist;
                    nearest = pos;
                }
            });

            if (nearest && minDist < TILE_SIZE * 2) {
                return { x: nearest.x, y: nearest.y, valid: true };
            }

            return { x: x, y: y, valid: false };
        }

        function findNearestSnapPoint(x, y, isPlayerTile = false) {
            const largeHexSize = TILE_SIZE * 4;
            const hexCoords = pixelToHex(x, y, largeHexSize);
            const snapPos = hexToPixel(hexCoords.q, hexCoords.r, largeHexSize);
            const distance = Math.sqrt(Math.pow(x - snapPos.x, 2) + Math.pow(y - snapPos.y, 2));

            if (distance < SNAP_THRESHOLD) {
                // Check if a tile already exists at this position
                const tileExists = placedTiles.some(tile => {
                    const dist = Math.sqrt(Math.pow(tile.x - snapPos.x, 2) + Math.pow(tile.y - snapPos.y, 2));
                    return dist < TILE_SIZE; // Tiles are considered overlapping if centers are very close
                });

                if (tileExists) {
                    return { x: x, y: y, snapped: false }; // Don't snap if position is occupied
                }

                // PLAYER TILE SPECIAL RULE: Must touch at least 2 unrevealed tiles
                if (isPlayerTile) {
                    const touchingUnrevealedCount = countTouchingUnrevealedTiles(snapPos.x, snapPos.y);
                    if (touchingUnrevealedCount < 2) {
                        console.log(`‚ùå Player tile at (${snapPos.x.toFixed(1)}, ${snapPos.y.toFixed(1)}) only touches ${touchingUnrevealedCount} unrevealed tile(s), need 2+`);
                        return { x: x, y: y, snapped: false }; // Don't allow placement
                    }
                    console.log(`‚úÖ Player tile at (${snapPos.x.toFixed(1)}, ${snapPos.y.toFixed(1)}) touches ${touchingUnrevealedCount} unrevealed tiles`);
                }

                return { x: snapPos.x, y: snapPos.y, snapped: true };
            }
            return { x: x, y: y, snapped: false };
        }

        function countTouchingUnrevealedTiles(tileX, tileY) {
            // Get the 6 adjacent tile positions in the large hex grid
            const largeHexSize = TILE_SIZE * 4;
            const tileHex = pixelToHex(tileX, tileY, largeHexSize);
            
            const adjacentOffsets = [
                { q: 1, r: 0 },   // East
                { q: 0, r: 1 },   // Southeast
                { q: -1, r: 1 },  // Southwest
                { q: -1, r: 0 },  // West
                { q: 0, r: -1 },  // Northwest
                { q: 1, r: -1 }   // Northeast
            ];

            let unrevealedCount = 0;

            adjacentOffsets.forEach(offset => {
                const adjQ = tileHex.q + offset.q;
                const adjR = tileHex.r + offset.r;
                const adjPos = hexToPixel(adjQ, adjR, largeHexSize);

                // Check if there's an unrevealed (flipped) tile at this position
                const adjacentTile = placedTiles.find(tile => {
                    const dist = Math.sqrt(Math.pow(tile.x - adjPos.x, 2) + Math.pow(tile.y - adjPos.y, 2));
                    return dist < TILE_SIZE;
                });

                if (adjacentTile && adjacentTile.flipped) {
                    unrevealedCount++;
                }
            });

            return unrevealedCount;
        }

        function tileHasStones(tileId) {
            const tile = placedTiles.find(t => t.id === tileId);
            if (!tile) return false;

            const s = TILE_SIZE;
            const hexagons = [
                { q: 0, r: 0 },
                { q: 1, r: 0 }, { q: 0, r: 1 }, { q: -1, r: 1 },
                { q: -1, r: 0 }, { q: 0, r: -1 }, { q: 1, r: -1 },
                { q: 2, r: -1 }, { q: 1, r: 1 }, { q: -1, r: 2 },
                { q: -2, r: 1 }, { q: -1, r: -1 }, { q: 1, r: -2 }
            ];

            return hexagons.some(hex => {
                const localPos = hexToPixel(hex.q, hex.r, s);
                const globalX = tile.x + localPos.x;
                const globalY = tile.y + localPos.y;

                return placedStones.some(stone => {
                    const dist = Math.sqrt(Math.pow(stone.x - globalX, 2) + Math.pow(stone.y - globalY, 2));
                    return dist < 5;
                });
            });
        }

        function updateTileClasses() {
            placedTiles.forEach(tile => {
                if (tileHasStones(tile.id)) {
                    tile.element.classList.add('has-stones');
                } else {
                    tile.element.classList.remove('has-stones');
                }
            });
        }

        function createShrineMarker(shrineType) {
            const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            g.setAttribute('class', 'shrine-marker');

            // Color mapping for shrine types
            const shrineColors = {
                'earth': '#69d83a',
                'water': '#5894f4',
                'fire': '#ed1b43',
                'wind': '#ffce00',
                'void': '#9458f4',
                'catacomb': '#8b4513'
            };

            // Symbol mapping for shrine types
            const shrineSymbols = {
                'earth': '‚ñ≤',
                'water': '‚óØ',
                'fire': '‚ô¶',
                'wind': '‚âã',
                'void': '‚ú∫',
                'catacomb': '‚ö∞'
            };

            // Create a circle background
            const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            circle.setAttribute('cx', '0');
            circle.setAttribute('cy', '0');
            circle.setAttribute('r', '8');
            circle.setAttribute('fill', shrineColors[shrineType]);
            circle.setAttribute('opacity', '0.6');
            circle.setAttribute('stroke', shrineColors[shrineType]);
            circle.setAttribute('stroke-width', '2');
            g.appendChild(circle);

            // Create the symbol text
            const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            text.setAttribute('x', '0');
            text.setAttribute('y', '0');
            text.setAttribute('text-anchor', 'middle');
            text.setAttribute('dominant-baseline', 'middle');
            text.setAttribute('fill', '#fff');
            text.setAttribute('font-size', '10');
            text.setAttribute('font-weight', 'bold');
            text.textContent = shrineSymbols[shrineType];
            g.appendChild(text);

            return g;
        }

        let nextTileId = 1; // Global counter for unique tile IDs

        function placeTile(x, y, rotation = 0, flipped = false, shrineType = null, isPlayerTile = false) {
            console.log(`   placeTile called: x=${x.toFixed(1)}, y=${y.toFixed(1)}, rotation=${rotation}, flipped=${flipped}, shrineType=${shrineType}, isPlayerTile=${isPlayerTile}`);
            const tileId = nextTileId++;
            console.log(`   Assigned tileId: ${tileId}`);
            const tileGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            tileGroup.setAttribute('class', isPlayerTile ? 'placed-tile player-tile' : 'placed-tile');
            tileGroup.setAttribute('data-tile-id', tileId);
            tileGroup.setAttribute('transform', `translate(${x}, ${y})`);

            const tile = createTileGroup(TILE_SIZE, rotation, flipped);
            tileGroup.appendChild(tile);

            // Draw from deck if shrine type not provided
            if (shrineType === null) {
                shrineType = drawNextTileFromDeck();
                if (shrineType === null) {
                    // No more tiles in deck
                    return null;
                }
            }

            // Check if this is the player tile
            if (shrineType === 'player') {
                isPlayerTile = true;
                
                // Assign a unique color for this player NOW (before adding elements)
                const colorNames = Object.keys(PLAYER_COLORS);
                const availableColors = colorNames.filter(name => !gameSessionColors.has(name));
                
                let assignedColor;
                if (availableColors.length > 0) {
                    const colorName = availableColors[Math.floor(Math.random() * availableColors.length)];
                    assignedColor = PLAYER_COLORS[colorName];
                    gameSessionColors.add(colorName);
                    console.log(`üé® Player ${playerPositions.length + 1} color assigned: ${colorName} (${assignedColor}). Used in game: ${Array.from(gameSessionColors).join(', ')}`);
                } else {
                    console.warn('‚ö†Ô∏è All colors used in this game!');
                    assignedColor = '#fff'; // Fallback to white
                }
                
                // Add color tint overlay to player tile
                const tintOverlay = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                tintOverlay.setAttribute('cx', 0);
                tintOverlay.setAttribute('cy', 0);
                tintOverlay.setAttribute('r', TILE_SIZE * 2); // Cover the whole tile
                tintOverlay.setAttribute('fill', assignedColor);
                tintOverlay.setAttribute('opacity', '0.15'); // Light tint
                tintOverlay.setAttribute('pointer-events', 'none'); // Don't interfere with clicks
                tileGroup.appendChild(tintOverlay);
                
                // Store the color for later use
                playerColor = assignedColor;
                
                // Add a group for element symbols on the player tile
                const symbolsGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                symbolsGroup.setAttribute('class', 'player-tile-element-symbols');
                tileGroup.appendChild(symbolsGroup);
            }

            // Only add shrine marker if NOT flipped and NOT player tile (revealed tiles show shrine)
            if (!flipped && shrineType !== 'player') {
                const shrineMarker = createShrineMarker(shrineType);
                tileGroup.appendChild(shrineMarker);
            }

            tileGroup.addEventListener('mousedown', (e) => {
                console.log(`üñ±Ô∏è Tile clicked: tileId=${tileId}, position=(${x.toFixed(1)}, ${y.toFixed(1)}), shrine=${shrineType}, flipped=${flipped}`);
                if (e.button === 0 && !tileHasStones(tileId) && !isPanning && !isDraggingStone) {
                    console.log(`   ‚úì Starting drag for tile ${tileId} at (${x.toFixed(1)}, ${y.toFixed(1)})`);
                    e.stopPropagation();
                    e.preventDefault();
                    startTileDrag(tileId, e);
                } else {
                    console.log(`   ‚úó Cannot drag: hasStones=${tileHasStones(tileId)}, isPanning=${isPanning}, isDraggingStone=${isDraggingStone}`);
                }
            });

            viewport.insertBefore(tileGroup, snapIndicator);

            placedTiles.push({
                id: tileId,
                x: x,
                y: y,
                rotation: rotation,
                flipped: flipped,
                element: tileGroup,
                shrineType: shrineType,
                isPlayerTile: isPlayerTile,
                playerIndex: isPlayerTile ? playerPositions.length : null // Track which player owns this tile
            });

            updateTileClasses();

            // Place player marker on player tile
            if (isPlayerTile) {
                // playerColor was already assigned above when adding the tint
                // Create a new player pawn at this tile's position
                placePlayer(x, y, playerColor);
                updateStatus(`Player ${playerPositions.length} tile placed!`);
            }

            return tileId;
        }

        function revealTile(tileId) {
            const tile = placedTiles.find(t => t.id === tileId);
            if (!tile || !tile.flipped) return; // Already revealed or doesn't exist

            // Remove the old tile element
            tile.element.remove();

            // Create new revealed tile group
            const tileGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            tileGroup.setAttribute('class', 'placed-tile');
            tileGroup.setAttribute('data-tile-id', tileId);
            tileGroup.setAttribute('transform', `translate(${tile.x}, ${tile.y})`);

            const tileGraphic = createTileGroup(TILE_SIZE, tile.rotation, false);
            tileGroup.appendChild(tileGraphic);

            // Add shrine marker
            const shrineMarker = createShrineMarker(tile.shrineType);
            tileGroup.appendChild(shrineMarker);

            tileGroup.addEventListener('mousedown', (e) => {
                if (e.button === 0 && !tileHasStones(tileId) && !isPanning && !isDraggingStone) {
                    e.stopPropagation();
                    e.preventDefault();
                    startTileDrag(tileId, e);
                }
            });

            viewport.insertBefore(tileGroup, snapIndicator);

            // Update tile data
            tile.flipped = false;
            tile.element = tileGroup;

            // Check for scroll discovery
            const scrollInfo = spellSystem.onTileRevealed(tile.shrineType);
            if (scrollInfo) {
                updateStatus(`Revealed ${tile.shrineType} shrine! Found ${scrollInfo.name}!`);
            } else {
                updateStatus(`Revealed ${tile.shrineType} shrine!`);
            }
        }

        function startTileDrag(tileId, e) {
            if (tileHasStones(tileId)) return;
            isDraggingTile = true;
            draggedTileId = tileId;
            draggedTileShrineType = null;
            draggedTileOriginalPos = null;
            const tile = placedTiles.find(t => t.id === tileId);
            if (tile) {
                draggedTileRotation = tile.rotation;
                draggedTileFlipped = tile.flipped || false;
                draggedTileShrineType = tile.shrineType; // Preserve shrine type
                draggedTileOriginalPos = { x: tile.x, y: tile.y }; // Store original position
                tile.element.remove();
                placedTiles = placedTiles.filter(t => t.id !== tileId);
            }

            const rect = boardSvg.getBoundingClientRect();
            const screenX = e.clientX - rect.left;
            const screenY = e.clientY - rect.top;
            const world = screenToWorld(screenX, screenY);

            ghostTile = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            ghostTile.setAttribute('class', 'ghost-tile');
            ghostTile.setAttribute('transform', `translate(${world.x}, ${world.y})`);
            const tileContent = createTileGroup(TILE_SIZE, draggedTileRotation, draggedTileFlipped);
            ghostTile.appendChild(tileContent);
            viewport.appendChild(ghostTile);
        }

        let isDraggingPlayer = false;
        let ghostPlayer = null;
        let playerPath = [];
        let pathLine = null;
        let pathCostLabels = [];

        function placePlayer(x, y, color = null) {
            if (color) {
                // Creating a NEW player pawn with this color
                console.log(`üé® Creating new player ${playerPositions.length + 1} at (${x.toFixed(1)}, ${y.toFixed(1)}) with color ${color}`);
                
                const playerGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                playerGroup.setAttribute('class', 'player');
                playerGroup.setAttribute('transform', `translate(${x}, ${y})`);

                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', 0);
                circle.setAttribute('cy', 0);
                circle.setAttribute('r', TILE_SIZE * 0.4);
                circle.setAttribute('class', 'player-marker');
                circle.setAttribute('fill', color);
                circle.setAttribute('stroke', '#000');
                circle.setAttribute('stroke-width', '2');
                
                playerGroup.appendChild(circle);
                
                // Store the player index for this group
                const playerIndex = playerPositions.length;
                
                // Add drag handler
                playerGroup.addEventListener('mousedown', (e) => {
                    // Only draggable if this is the active player (check dynamically)
                    const thisPlayerIndex = playerPositions.findIndex(p => p.element === playerGroup);
                    if (thisPlayerIndex === activePlayerIndex) {
                        e.stopPropagation();
                        e.preventDefault();
                        startPlayerDrag(e);
                    }
                });

                playerGroup.addEventListener('mouseenter', (e) => {
                    e.stopPropagation();
                });

                playerGroup.addEventListener('mouseleave', (e) => {
                    e.stopPropagation();
                });

                viewport.appendChild(playerGroup);
                
                playerPositions.push({ x, y, element: playerGroup, color, index: playerIndex });
                
            } else {
                // Moving the ACTIVE player
                const activePlayer = playerPositions[activePlayerIndex];
                if (!activePlayer) {
                    console.error('No active player to move!');
                    return;
                }
                
                activePlayer.element.remove();
                
                const playerGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                playerGroup.setAttribute('class', 'player');
                playerGroup.setAttribute('transform', `translate(${x}, ${y})`);

                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', 0);
                circle.setAttribute('cy', 0);
                circle.setAttribute('r', TILE_SIZE * 0.4);
                circle.setAttribute('class', 'player-marker');
                circle.setAttribute('fill', activePlayer.color);
                circle.setAttribute('stroke', '#000');
                circle.setAttribute('stroke-width', '2');

                playerGroup.appendChild(circle);
                
                playerGroup.addEventListener('mousedown', (e) => {
                    // Only draggable if this is the active player
                    if (activePlayerIndex === activePlayer.index) {
                        e.stopPropagation();
                        e.preventDefault();
                        startPlayerDrag(e);
                    }
                });

                playerGroup.addEventListener('mouseenter', (e) => {
                    e.stopPropagation();
                });

                playerGroup.addEventListener('mouseleave', (e) => {
                    e.stopPropagation();
                });

                viewport.appendChild(playerGroup);

                activePlayer.x = x;
                activePlayer.y = y;
                activePlayer.element = playerGroup;
            }

            // Update catacomb teleport indicators
            updateCatacombIndicators();
        }

        function updatePlayerElementSymbols(playerIndex = null) {
            // If no player index specified, use active player
            if (playerIndex === null) {
                playerIndex = activePlayerIndex;
            }
            
            // Find THIS player's tile
            const playerTile = placedTiles.find(t => t.isPlayerTile && t.playerIndex === playerIndex);
            if (!playerTile) {
                console.log(`No player tile found for player ${playerIndex}`);
                return;
            }

            const symbolsGroup = playerTile.element.querySelector('.player-tile-element-symbols');
            if (!symbolsGroup) return;

            // Clear existing symbols
            symbolsGroup.innerHTML = '';

            // Get activated elements for THIS specific player
            const playerScrollData = spellSystem.playerScrolls[playerIndex];
            if (!playerScrollData) return;
            
            const activatedElements = Array.from(playerScrollData.activated);
            
            if (activatedElements.length === 0) return;

            // Arrange symbols in a pentagon pattern around the tile center
            const radius = TILE_SIZE * 1.5; // Place symbols on the outer part of the tile
            const angleStep = (Math.PI * 2) / 5; // 5 elements
            const elementOrder = ['earth', 'water', 'fire', 'wind', 'void'];

            activatedElements.forEach(element => {
                const index = elementOrder.indexOf(element);
                const angle = angleStep * index - Math.PI / 2; // Start at top
                const x = Math.cos(angle) * radius;
                const y = Math.sin(angle) * radius;

                // Create symbol with background circle
                const symbolBg = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                symbolBg.setAttribute('cx', x);
                symbolBg.setAttribute('cy', y);
                symbolBg.setAttribute('r', '18');
                symbolBg.setAttribute('fill', STONE_TYPES[element].color);
                symbolBg.setAttribute('stroke', '#fff');
                symbolBg.setAttribute('stroke-width', '2');
                symbolsGroup.appendChild(symbolBg);

                // Create symbol
                const symbol = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                symbol.setAttribute('x', x);
                symbol.setAttribute('y', y);
                symbol.setAttribute('text-anchor', 'middle');
                symbol.setAttribute('dominant-baseline', 'middle');
                symbol.setAttribute('fill', '#fff');
                symbol.setAttribute('font-size', '20');
                symbol.setAttribute('font-weight', 'bold');
                symbol.setAttribute('stroke', '#000');
                symbol.setAttribute('stroke-width', '0.5');
                symbol.textContent = STONE_TYPES[element].symbol;

                symbolsGroup.appendChild(symbol);
            });

            console.log(`üé® Updated player ${playerIndex}'s TILE with ${activatedElements.length} element symbol(s): ${activatedElements.join(', ')}`);
        }

        function startPlayerDrag(e) {
            isDraggingPlayer = true;
            playerPath = [{ x: playerPosition.x, y: playerPosition.y, cost: 0 }];
            lastAttemptedHex = null; // Reset logging state
            playerPosition.element.remove();

            const rect = boardSvg.getBoundingClientRect();
            const screenX = e.clientX - rect.left;
            const screenY = e.clientY - rect.top;
            const world = screenToWorld(screenX, screenY);

            ghostPlayer = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            ghostPlayer.setAttribute('class', 'player stone-ghost');
            ghostPlayer.setAttribute('transform', `translate(${world.x}, ${world.y})`);

            const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            circle.setAttribute('cx', 0);
            circle.setAttribute('cy', 0);
            circle.setAttribute('r', TILE_SIZE * 0.4);
            circle.setAttribute('class', 'player-marker');

            ghostPlayer.appendChild(circle);
            viewport.appendChild(ghostPlayer);

            // Create path line
            pathLine = document.createElementNS('http://www.w3.org/2000/svg', 'polyline');
            pathLine.setAttribute('fill', 'none');
            pathLine.setAttribute('stroke', '#58a4f4');
            pathLine.setAttribute('stroke-width', '3');
            pathLine.setAttribute('stroke-dasharray', '5,5');
            pathLine.setAttribute('opacity', '0.7');
            viewport.insertBefore(pathLine, ghostPlayer);
        }

        let lastAttemptedHex = null;

        // Find if target is reachable through a chain of wind stones/water-with-wind
        function findWindPath(startX, startY, targetX, targetY) {
            // BFS to find path through wind stones
            const queue = [{x: startX, y: startY, path: []}];
            const visited = new Set();
            visited.add(`${startX.toFixed(1)},${startY.toFixed(1)}`);

            while (queue.length > 0) {
                const current = queue.shift();

                // Get all wind stones and water-with-wind adjacent to current position
                const windStones = getAdjacentWindStones(current.x, current.y);

                // Also check water with chained wind
                const neighbors = getNeighborStones(current.x, current.y);
                const waterWithWind = neighbors.filter(n => {
                    if (n.type !== 'water') return false;
                    const chainedAbility = getChainedAbility(n.x, n.y);
                    return chainedAbility === 'wind';
                });

                const allWindSources = [...windStones, ...waterWithWind];

                for (const windSource of allWindSources) {
                    const key = `${windSource.x.toFixed(1)},${windSource.y.toFixed(1)}`;

                    // Skip if nullified by void
                    const hasVoid = hasAdjacentStoneType(windSource.x, windSource.y, 'void');
                    if (hasVoid) continue;

                    // Check if target is adjacent to this wind source
                    const windNeighbors = getNeighborHexPositions(windSource.x, windSource.y);
                    const canReachTarget = windNeighbors.some(n =>
                        Math.sqrt(Math.pow(n.x - targetX, 2) + Math.pow(n.y - targetY, 2)) < 5
                    );

                    if (canReachTarget) {
                        // Found a path!
                        return [...current.path, windSource];
                    }

                    // Continue searching through this wind source
                    if (!visited.has(key)) {
                        visited.add(key);
                        queue.push({
                            x: windSource.x,
                            y: windSource.y,
                            path: [...current.path, windSource]
                        });
                    }
                }
            }

            return null; // No path found
        }

        function findGeneralPath(startX, startY, targetX, targetY, maxCost) {
            // A* pathfinding to find cheapest path through any hex
            const openSet = [{x: startX, y: startY, path: [], cost: 0, priority: 0}];
            const visited = new Map();

            while (openSet.length > 0) {
                // Get node with lowest priority (cost + heuristic)
                openSet.sort((a, b) => a.priority - b.priority);
                const current = openSet.shift();

                const key = `${current.x.toFixed(1)},${current.y.toFixed(1)}`;

                // Skip if we've visited this with lower cost
                if (visited.has(key) && visited.get(key) <= current.cost) continue;
                visited.set(key, current.cost);

                // Check if we reached the target
                const distToTarget = Math.sqrt(Math.pow(current.x - targetX, 2) + Math.pow(current.y - targetY, 2));
                if (distToTarget < 5) {
                    return { path: current.path, cost: current.cost };
                }

                // Explore neighbors
                const neighbors = getNeighborHexPositions(current.x, current.y);
                for (const neighbor of neighbors) {
                    const moveCheck = canPlayerMoveToHex(neighbor.x, neighbor.y);

                    if (moveCheck.canMove) {
                        const newCost = current.cost + moveCheck.cost;

                        // Skip if would exceed max cost
                        if (newCost > maxCost) continue;

                        const neighborKey = `${neighbor.x.toFixed(1)},${neighbor.y.toFixed(1)}`;

                        // Skip if already visited with lower cost
                        if (visited.has(neighborKey) && visited.get(neighborKey) <= newCost) continue;

                        // Calculate heuristic (straight-line distance to target)
                        const heuristic = Math.sqrt(Math.pow(neighbor.x - targetX, 2) + Math.pow(neighbor.y - targetY, 2)) / TILE_SIZE;

                        openSet.push({
                            x: neighbor.x,
                            y: neighbor.y,
                            path: [...current.path, {x: neighbor.x, y: neighbor.y, cost: moveCheck.cost}],
                            cost: newCost,
                            priority: newCost + heuristic
                        });
                    }
                }
            }

            return null; // No path found
        }

        function getAdjacentWindStones(x, y) {
            const neighbors = getNeighborHexPositions(x, y);
            const windStones = [];

            neighbors.forEach(neighborPos => {
                const stone = placedStones.find(s => {
                    const dist = Math.sqrt(Math.pow(s.x - neighborPos.x, 2) + Math.pow(s.y - neighborPos.y, 2));
                    if (dist >= 5) return false;

                    // Check if it's wind or water mimicking wind
                    const effectiveType = getEffectiveStoneType(s);
                    return effectiveType === 'wind';
                });
                if (stone) {
                    windStones.push(stone);
                }
            });

            return windStones;
        }

        function getAdjacentEarthStones(x, y) {
            const neighbors = getNeighborHexPositions(x, y);
            const earthStones = [];

            neighbors.forEach(neighborPos => {
                const stone = placedStones.find(s => {
                    const dist = Math.sqrt(Math.pow(s.x - neighborPos.x, 2) + Math.pow(s.y - neighborPos.y, 2));
                    if (dist >= 5) return false;

                    // Check if it's earth or water mimicking earth
                    const effectiveType = getEffectiveStoneType(s);
                    return effectiveType === 'earth';
                });
                if (stone) {
                    earthStones.push(stone);
                }
            });

            return earthStones;
        }

        // Get the chained ability for a water stone by flood-filling through connected water
        function getChainedAbility(x, y) {
            // Only water stones can receive chained abilities
            const stone = placedStones.find(s => {
                const dist = Math.sqrt(Math.pow(s.x - x, 2) + Math.pow(s.y - y, 2));
                return dist < 5;
            });

            if (!stone || stone.type !== 'water') {
                return null; // Not a water stone
            }

            // Check if THIS water stone is nullified by void
            const waterNullified = hasAdjacentStoneType(x, y, 'void');
            if (waterNullified) {
                return null; // Water's chaining ability is nullified by adjacent void
            }

            // Flood fill through connected water to find wind/earth sources
            const visited = new Set();
            const queue = [{x, y}];
            visited.add(`${x.toFixed(1)},${y.toFixed(1)}`);

            let hasWind = false;
            let hasEarth = false;

            while (queue.length > 0) {
                const current = queue.shift();
                const neighbors = getNeighborStones(current.x, current.y);

                for (const neighbor of neighbors) {
                    const key = `${neighbor.x.toFixed(1)},${neighbor.y.toFixed(1)}`;

                    // Check if this neighbor is a source stone (wind or earth, not nullified by void)
                    if (neighbor.type === 'wind') {
                        const voidNullified = hasAdjacentStoneType(neighbor.x, neighbor.y, 'void');
                        if (!voidNullified) {
                            hasWind = true;
                        }
                    } else if (neighbor.type === 'earth') {
                        const voidNullified = hasAdjacentStoneType(neighbor.x, neighbor.y, 'void');
                        if (!voidNullified) {
                            hasEarth = true;
                        }
                    }

                    // If neighbor is water and not visited, add to queue to continue flood fill
                    if (neighbor.type === 'water' && !visited.has(key)) {
                        // Check if this water is nullified by void
                        const neighborWaterNullified = hasAdjacentStoneType(neighbor.x, neighbor.y, 'void');
                        if (!neighborWaterNullified) {
                            visited.add(key);
                            queue.push({x: neighbor.x, y: neighbor.y});
                        }
                    }
                }
            }

            // Wind outranks earth
            if (hasWind) return 'wind';
            if (hasEarth) return 'earth';
            return null; // No chained ability
        }

        function updatePlayerPath(x, y) {
            const hexPositions = getAllHexagonPositions();
            let nearest = null;
            let minDist = Infinity;

            hexPositions.forEach(pos => {
                const dist = Math.sqrt(Math.pow(x - pos.x, 2) + Math.pow(y - pos.y, 2));
                if (dist < minDist) {
                    minDist = dist;
                    nearest = pos;
                }
            });

            if (nearest && minDist < TILE_SIZE * 1.5) {
                const lastPos = playerPath[playerPath.length - 1];
                const isDifferentHex = Math.sqrt(Math.pow(nearest.x - lastPos.x, 2) + Math.pow(nearest.y - lastPos.y, 2)) > 5;

                if (isDifferentHex) {
                    // Check if this is adjacent to the last position
                    const neighbors = getNeighborHexPositions(lastPos.x, lastPos.y);
                    let isAdjacent = neighbors.some(n =>
                        Math.sqrt(Math.pow(n.x - nearest.x, 2) + Math.pow(n.y - nearest.y, 2)) < 5
                    );

                    // Only log once per hex attempt
                    const hexKey = `${nearest.x.toFixed(1)},${nearest.y.toFixed(1)}`;
                    const shouldLog = hexKey !== lastAttemptedHex;
                    if (shouldLog) lastAttemptedHex = hexKey;

                    if (isAdjacent) {
                        // Only add adjacent moves - follow the exact path you drag
                        const moveCheck = canPlayerMoveToHex(nearest.x, nearest.y, shouldLog);
                        if (shouldLog) {
                            console.log(`üéØ Attempting to add hex (${nearest.x.toFixed(1)}, ${nearest.y.toFixed(1)}): canMove=${moveCheck.canMove}, cost=${moveCheck.cost}`);
                        }
                        if (moveCheck.canMove) {
                            const totalCost = calculatePathCost();
                            if (totalCost + moveCheck.cost <= getTotalAP()) {
                                playerPath.push({ x: nearest.x, y: nearest.y, cost: moveCheck.cost });
                                if (shouldLog) {
                                    console.log(`‚úÖ Added to path! Total cost now: ${totalCost + moveCheck.cost}`);
                                }
                            } else if (shouldLog) {
                                console.log(`‚ö†Ô∏è Cannot extend path to (${nearest.x.toFixed(1)}, ${nearest.y.toFixed(1)}): Insufficient AP (need ${totalCost + moveCheck.cost}, have ${getTotalAP()})`);
                            }
                        } else if (shouldLog) {
                            console.log(`‚ùå Cannot add to path - movement blocked`);
                        }
                    }
                    // Removed automatic pathfinding - only follow what you drag
                }
            }

            // Update path line
            if (pathLine && playerPath.length > 1) {
                const points = playerPath.map(p => `${p.x},${p.y}`).join(' ');
                pathLine.setAttribute('points', points);
            }

            // Update AP cost labels
            updatePathLabels();
        }

        function updatePathLabels() {
            // Remove old labels
            pathCostLabels.forEach(label => label.remove());
            pathCostLabels = [];

            if (playerPath.length < 2) return;

            // Calculate cumulative costs and remaining AP for each segment
            let cumulativeCost = 0;

            for (let i = 1; i < playerPath.length; i++) {
                const currentSegment = playerPath[i];
                cumulativeCost += currentSegment.cost;
                const remainingAP = currentAP - cumulativeCost;

                // Calculate midpoint between this segment and previous
                const prevSegment = playerPath[i - 1];
                const midX = (currentSegment.x + prevSegment.x) / 2;
                const midY = (currentSegment.y + prevSegment.y) / 2;

                // Create label
                const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                label.setAttribute('x', midX);
                label.setAttribute('y', midY - 8); // Offset above the line
                label.setAttribute('text-anchor', 'middle');
                label.setAttribute('fill', remainingAP >= 0 ? '#2ecc71' : '#e74c3c');
                label.setAttribute('font-size', '14');
                label.setAttribute('font-weight', 'bold');
                label.setAttribute('stroke', '#000');
                label.setAttribute('stroke-width', '0.5');
                label.setAttribute('paint-order', 'stroke');
                label.textContent = remainingAP;

                viewport.appendChild(label);
                pathCostLabels.push(label);
            }
        }

        function getNeighborHexPositions(x, y) {
            const neighbors = [];
            const s = TILE_SIZE;
            const dirs = [
                { q: 1, r: 0 }, { q: 1, r: -1 }, { q: 0, r: -1 },
                { q: -1, r: 0 }, { q: -1, r: 1 }, { q: 0, r: 1 }
            ];

            for (const dir of dirs) {
                const pos = hexToPixel(dir.q, dir.r, s);
                neighbors.push({ x: x + pos.x, y: y + pos.y });
            }
            return neighbors;
        }

        function calculatePathCost() {
            let totalCost = 0;
            for (let i = 1; i < playerPath.length; i++) {
                totalCost += playerPath[i].cost;
            }
            return totalCost;
        }

        let nextStoneId = 1; // Global counter for unique stone IDs

        function placeStone(x, y, type) {
            const stoneId = nextStoneId++;
            console.log(`   Placing stone: id=${stoneId}, type=${type}, position=(${x.toFixed(1)}, ${y.toFixed(1)})`);
            const stoneGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            stoneGroup.setAttribute('class', 'stone');
            stoneGroup.setAttribute('data-stone-id', stoneId);
            stoneGroup.setAttribute('transform', `translate(${x}, ${y})`);

            const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            circle.setAttribute('cx', 0);
            circle.setAttribute('cy', 0);
            circle.setAttribute('r', STONE_SIZE);
            circle.setAttribute('class', 'stone-piece');
            circle.setAttribute('fill', STONE_TYPES[type].color);

            const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            text.setAttribute('x', 0);
            text.setAttribute('y', 0);
            text.setAttribute('text-anchor', 'middle');
            text.setAttribute('dominant-baseline', 'middle');
            text.setAttribute('fill', '#fff');
            text.setAttribute('font-size', '14');
            text.setAttribute('font-weight', 'bold');
            text.textContent = STONE_TYPES[type].symbol;

            stoneGroup.appendChild(circle);
            stoneGroup.appendChild(text);

            stoneGroup.addEventListener('mousedown', (e) => {
                e.stopPropagation();
                e.preventDefault();
                // Stone dragging disabled - stones can only be placed from pool or broken (right-click)
                updateStatus('üí° Right-click to break this stone (costs AP based on rank)');
            });

            stoneGroup.addEventListener('contextmenu', (e) => {
                e.stopPropagation();
                e.preventDefault();
                attemptBreakStone(stoneId);
            });

            stoneGroup.addEventListener('mouseenter', (e) => {
                e.stopPropagation();
                
                // Check if stone is adjacent to player and show break cost
                const stone = placedStones.find(s => s.id === stoneId);
                if (stone && playerPosition && isAdjacentToPlayer(stone.x, stone.y)) {
                    const STONE_RANK = { 'void': 1, 'wind': 2, 'fire': 3, 'water': 4, 'earth': 5 };
                    const breakCost = STONE_RANK[stone.type];
                    const canAffordBreak = getTotalAP() >= breakCost;
                    
                    stoneGroup.style.cursor = 'pointer';
                    stoneGroup.style.filter = canAffordBreak ? 'brightness(1.3)' : 'brightness(0.7)';
                    
                    updateStatus(`Right-click to break ${stone.type} stone (${breakCost} AP)${canAffordBreak ? '' : ' - Not enough AP!'}`);
                }
            });

            stoneGroup.addEventListener('mouseleave', (e) => {
                e.stopPropagation();
                stoneGroup.style.filter = '';
            });

            viewport.appendChild(stoneGroup);

            placedStones.push({
                id: stoneId,
                x: x,
                y: y,
                type: type,
                element: stoneGroup
            });

            updateTileClasses();
            processStoneInteractions(x, y, type);

            // Re-check all fire stones in case void was moved away
            recheckAllStoneInteractions();

            // Update visuals for all water stones (mimicry indicators)
            updateAllWaterStoneVisuals();

            // Update void nullification indicators
            updateAllVoidNullificationVisuals();

            return stoneId;
        }

        function updateAllWaterStoneVisuals() {
            // Update all water stones to show what they're mimicking
            placedStones.forEach(stone => {
                if (stone.type === 'water') {
                    updateWaterStoneVisual(stone);
                }
            });
        }

        function updateAllVoidNullificationVisuals() {
            // Update all stones to show if they're nullified by void
            placedStones.forEach(stone => {
                // Remove any existing nullification indicator
                const existingNullIndicator = stone.element.querySelector('.void-nullification-indicator');
                if (existingNullIndicator) {
                    existingNullIndicator.remove();
                }

                // Check if this stone is nullified by adjacent void
                // (Only fire, wind, and earth have abilities that can be nullified)
                if (stone.type === 'fire' || stone.type === 'wind' || stone.type === 'earth') {
                    const hasVoid = hasAdjacentStoneType(stone.x, stone.y, 'void');
                    if (hasVoid) {
                        // Add nullification indicator (X or crossed-out effect)
                        const nullIndicator = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                        nullIndicator.setAttribute('cx', 0);
                        nullIndicator.setAttribute('cy', 0);
                        nullIndicator.setAttribute('r', STONE_SIZE + 3);
                        nullIndicator.setAttribute('class', 'void-nullification-indicator');
                        nullIndicator.setAttribute('fill', 'none');
                        nullIndicator.setAttribute('stroke', STONE_TYPES['void'].color);
                        nullIndicator.setAttribute('stroke-width', '2');
                        nullIndicator.setAttribute('stroke-dasharray', '2,2');
                        nullIndicator.setAttribute('opacity', '0.6');

                        // Insert before other elements
                        stone.element.insertBefore(nullIndicator, stone.element.firstChild);

                        console.log(`‚ú® ${stone.type} at (${stone.x.toFixed(1)}, ${stone.y.toFixed(1)}) is nullified by void`);
                    }
                }
            });
        }

        function updateWaterStoneVisual(waterStone) {
            const effectiveType = getEffectiveStoneType(waterStone);
            const chainedAbility = getChainedAbility(waterStone.x, waterStone.y);

            // Remove any existing indicators
            const existingIndicator = waterStone.element.querySelector('.mimicry-indicator');
            if (existingIndicator) {
                existingIndicator.remove();
            }
            const existingChainIndicator = waterStone.element.querySelector('.chain-indicator');
            if (existingChainIndicator) {
                existingChainIndicator.remove();
            }

            // Determine what to show: chained ability takes precedence over mimicry
            // because chaining uses wind-outranks-earth logic
            const displayAbility = chainedAbility || (effectiveType !== 'water' ? effectiveType : null);

            if (displayAbility) {
                const isChained = !!chainedAbility;
                const indicator = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                indicator.setAttribute('cx', 0);
                indicator.setAttribute('cy', 0);
                indicator.setAttribute('r', STONE_SIZE + 3);
                indicator.setAttribute('class', isChained ? 'chain-indicator' : 'mimicry-indicator');
                indicator.setAttribute('fill', 'none');
                indicator.setAttribute('stroke', STONE_TYPES[displayAbility].color);
                indicator.setAttribute('stroke-width', '2');
                indicator.setAttribute('stroke-dasharray', isChained ? '5,2' : '3,3');
                if (isChained) {
                    indicator.setAttribute('opacity', '0.7');
                }

                // Insert before other elements
                waterStone.element.insertBefore(indicator, waterStone.element.firstChild);

                if (isChained) {
                    console.log(`üîó Water at (${waterStone.x.toFixed(1)}, ${waterStone.y.toFixed(1)}) has chained ${displayAbility} ability`);
                } else {
                    console.log(`üíß Water at (${waterStone.x.toFixed(1)}, ${waterStone.y.toFixed(1)}) is mimicking ${displayAbility}`);
                }
            }
        }

        function getNeighborStones(x, y) {
            const neighbors = [];
            const hexPositions = getAllHexagonPositions();

            hexPositions.forEach(pos => {
                const dist = Math.sqrt(Math.pow(x - pos.x, 2) + Math.pow(y - pos.y, 2));
                if (dist > 5 && dist < TILE_SIZE * 2.5) {
                    const stone = placedStones.find(s => {
                        const stoneDist = Math.sqrt(Math.pow(s.x - pos.x, 2) + Math.pow(s.y - pos.y, 2));
                        return stoneDist < 5;
                    });
                    if (stone) {
                        neighbors.push(stone);
                    }
                }
            });

            return neighbors;
        }

        function hasAdjacentStoneType(x, y, type) {
            const neighbors = getNeighborStones(x, y);
            return neighbors.some(s => s.type === type);
        }

        // Stone rank for water mimicry priority (lower = higher priority)
        const STONE_RANK = {
            'void': 1,
            'wind': 2,
            'fire': 3,
            'water': 4,
            'earth': 5
        };

        // Get the effective type of a stone (considering water mimicry)
        function getEffectiveStoneType(stone) {
            if (stone.type !== 'water') {
                return stone.type;
            }

            // Water mimics adjacent stones
            const neighbors = getNeighborStones(stone.x, stone.y);
            if (neighbors.length === 0) {
                return 'water'; // No neighbors, just water
            }

            // Find highest-ranked adjacent stone (lowest rank number)
            let bestRank = Infinity;
            let mimicType = 'water';

            neighbors.forEach(neighbor => {
                const rank = STONE_RANK[neighbor.type] || 999;
                if (rank < bestRank && neighbor.type !== 'water') {
                    bestRank = rank;
                    mimicType = neighbor.type;
                }
            });

            return mimicType;
        }

        function recheckAllStoneInteractions() {
            // Re-check interactions for all fire stones on the board
            // This ensures fire destroys adjacent stones when void is removed
            const fireStones = placedStones.filter(s => s.type === 'fire');

            fireStones.forEach(stone => {
                const fireHasVoid = hasAdjacentStoneType(stone.x, stone.y, 'void');
                if (!fireHasVoid) {
                    // Fire is not nullified, check what it should destroy
                    const neighbors = getNeighborStones(stone.x, stone.y);
                    const stonesToDestroy = [];
                    neighbors.forEach(neighbor => {
                        // Fire destroys ALL stones except void and fire
                        // (Water is NOT protected - fire destroys water)
                        if (neighbor.type !== 'void' && neighbor.type !== 'fire') {
                            stonesToDestroy.push(neighbor.id);
                        }
                    });

                    // Destroy adjacent stones (using direct removal to avoid recursion)
                    stonesToDestroy.forEach(targetId => {
                        const target = placedStones.find(s => s.id === targetId);
                        if (target) {
                            target.element.remove();
                            placedStones = placedStones.filter(s => s.id !== targetId);
                            returnStoneToPool(target.type);
                            updateStatus(`Fire destroyed ${target.type} stone!`);
                        }
                    });
                }
            });
        }

        function processStoneInteractions(x, y, type) {
            const neighbors = getNeighborStones(x, y);

            // Special case: water stone placed with both fire and a higher-priority stone
            // Water mimics the higher-priority stone, then gets destroyed by fire
            if (type === 'water') {
                const hasFire = neighbors.some(n => n.type === 'fire');
                if (hasFire) {
                    // Check what the water would mimic
                    const effectiveType = getEffectiveStoneType({ x, y, type: 'water' });
                    // If water is mimicking something other than water or fire, it gets destroyed
                    if (effectiveType !== 'water' && effectiveType !== 'fire') {
                        const stoneToRemove = placedStones.find(s => s.x === x && s.y === y);
                        if (stoneToRemove) {
                            setTimeout(() => {
                                removeStone(stoneToRemove.id);
                                updateStatus(`Water mimicked ${effectiveType}, then was destroyed by fire!`);
                            }, 100);
                        }
                        return; // Stop processing other interactions
                    }
                }
            }

            // Fire destroys adjacent non-void, non-fire stones
            // But only if fire itself is not nullified by an adjacent void
            if (type === 'fire') {
                const fireHasVoid = hasAdjacentStoneType(x, y, 'void');

                if (!fireHasVoid) {
                    const stonesToDestroy = [];
                    neighbors.forEach(neighbor => {
                        // Don't destroy void or fire
                        // Fire destroys ALL other stones, even if they're voided
                        if (neighbor.type !== 'void' && neighbor.type !== 'fire') {
                            stonesToDestroy.push(neighbor);
                        }
                    });

                    // Destroy all adjacent stones (voided or not)
                    stonesToDestroy.forEach(stone => {
                        removeStone(stone.id);
                        updateStatus(`Fire destroyed ${stone.type} stone!`);
                    });
                }
            }

            // Fire also checks incoming threats
            neighbors.forEach(neighbor => {
                if (neighbor.type === 'fire' && type !== 'void' && type !== 'fire') {
                    const hasVoid = hasAdjacentStoneType(neighbor.x, neighbor.y, 'void');
                    if (!hasVoid) {
                        const stoneToRemove = placedStones.find(s => s.x === x && s.y === y);
                        if (stoneToRemove) {
                            removeStone(stoneToRemove.id);
                            updateStatus(`Fire destroyed ${type} stone!`);
                        }
                    }
                }
            });
        }

        function removeStone(stoneId) {
            const stone = placedStones.find(s => s.id === stoneId);
            if (stone) {
                stone.element.remove();
                placedStones = placedStones.filter(s => s.id !== stoneId);
                returnStoneToPool(stone.type);
                updateTileClasses();

                // Re-check all fire stones to see if they should activate
                recheckAllStoneInteractions();

                // Update all water stone visuals since chaining may have changed
                updateAllWaterStoneVisuals();

                // Update void nullification indicators
                updateAllVoidNullificationVisuals();
            }
        }

        function canPlayerMoveToHex(x, y, logBlocked = false) {
            const stone = placedStones.find(s => {
                const dist = Math.sqrt(Math.pow(s.x - x, 2) + Math.pow(s.y - y, 2));
                return dist < 5;
            });

            if (!stone) return { canMove: true, cost: 1 };

            // Handle water stones with chaining
            if (stone.type === 'water') {
                const chainedAbility = getChainedAbility(x, y);
                console.log(`üíß Water at (${x.toFixed(1)}, ${y.toFixed(1)}) has chained ability: ${chainedAbility || 'none'}`);

                if (chainedAbility === 'wind') {
                    // Wind chains through water - free movement
                    console.log(`‚úì Wind chaining active - water becomes free movement`);
                    return { canMove: true, cost: 0 };
                } else if (chainedAbility === 'earth') {
                    // Earth chains through water - blocks movement
                    console.log(`‚úì Earth chaining active - water blocks movement`);
                    if (logBlocked) console.log(`‚ùå Cannot move to (${x.toFixed(1)}, ${y.toFixed(1)}): Water has chained Earth ability (blocks movement)`);
                    return { canMove: false, cost: Infinity };
                }

                // No chaining effects, normal water cost
                console.log(`üíß No chaining - normal water cost (2 AP)`);
                return { canMove: true, cost: 2 };
            }

            // Handle non-water stones based on their ACTUAL type, not mimicry
            // (Mimicry is visual only, doesn't affect movement)

            // Earth blocks movement (unless nullified by void)
            if (stone.type === 'earth') {
                const hasVoid = hasAdjacentStoneType(x, y, 'void');
                if (hasVoid) return { canMove: true, cost: 1 }; // Nullified by void, reverts to baseline
                if (logBlocked) console.log(`‚ùå Cannot move to (${x.toFixed(1)}, ${y.toFixed(1)}): Earth stone blocks movement (needs adjacent Void to nullify)`);
                return { canMove: false, cost: Infinity };
            }

            // Wind is free (0 cost) - ability overrides baseline
            if (stone.type === 'wind') {
                const hasVoid = hasAdjacentStoneType(x, y, 'void');
                if (hasVoid) return { canMove: true, cost: 1 }; // Nullified by void, reverts to baseline
                return { canMove: true, cost: 0 }; // Wind ability: free movement
            }

            // All other stones (void, fire, etc.) cost 1 AP (baseline)
            return { canMove: true, cost: 1 };
        }

        function startStoneDrag(stoneId, e) {
            const stone = placedStones.find(s => s.id === stoneId);
            if (!stone) {
                console.log('‚ùå Stone not found for dragging');
                return;
            }

            // Check if stone is adjacent to player
            if (!playerPosition) {
                updateStatus('‚ùå No player on board!');
                return;
            }

            if (!isAdjacentToPlayer(stone.x, stone.y)) {
                updateStatus('‚ùå Can only move stones adjacent to player!');
                console.log(`‚ùå Cannot drag stone id=${stoneId}: not adjacent to player`);
                return;
            }

            console.log(`‚úÖ Starting drag for stone id=${stoneId}, type=${stone.type} (adjacent to player)`);

            isDraggingStone = true;
            draggedStoneId = stoneId;
            draggedStoneType = stone.type;
            stone.element.remove();
            placedStones = placedStones.filter(s => s.id !== stoneId);
            updateTileClasses();

            // Re-check all fire stones to see if they should activate/deactivate
            recheckAllStoneInteractions();

            // Update all water stone visuals since chaining may have changed
            updateAllWaterStoneVisuals();

            // Update void nullification indicators
            updateAllVoidNullificationVisuals();

            const rect = boardSvg.getBoundingClientRect();
            const screenX = e.clientX - rect.left;
            const screenY = e.clientY - rect.top;
            const world = screenToWorld(screenX, screenY);

            ghostStone = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            ghostStone.setAttribute('class', 'stone stone-ghost');
            ghostStone.setAttribute('transform', `translate(${world.x}, ${world.y})`);

            const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            circle.setAttribute('cx', 0);
            circle.setAttribute('cy', 0);
            circle.setAttribute('r', STONE_SIZE);
            circle.setAttribute('class', 'stone-piece');
            circle.setAttribute('fill', STONE_TYPES[draggedStoneType].color);

            const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            text.setAttribute('x', 0);
            text.setAttribute('y', 0);
            text.setAttribute('text-anchor', 'middle');
            text.setAttribute('dominant-baseline', 'middle');
            text.setAttribute('fill', '#fff');
            text.setAttribute('font-size', '14');
            text.setAttribute('font-weight', 'bold');
            text.textContent = STONE_TYPES[draggedStoneType].symbol;

            ghostStone.appendChild(circle);
            ghostStone.appendChild(text);
            viewport.appendChild(ghostStone);
        }

        function updateStoneCount(type) {
            document.getElementById(type + '-count').textContent = stoneCounts[type] + '/' + stoneCapacity[type];
            updateSourceCount(type);
            
            // Update void AP whenever void stones change
            if (type === 'void') {
                console.log(`üìä Void stones changed to ${playerPool.void}, updating void AP to match`);
                updateVoidAP();
            }
        }

        function updateSourceCount(type) {
            document.getElementById(type + '-source').textContent = 'Source: ' + sourcePool[type] + '/' + sourcePoolCapacity[type];
        }

        function returnStoneToPool(type) {
            // Return a stone to the SOURCE pool (not player pool)
            // This happens when stones are removed from board or destroyed
            const maxStones = sourcePoolCapacity[type];
            if (sourcePool[type] < maxStones) {
                sourcePool[type]++;
                updateSourceCount(type);
                console.log(`‚ôªÔ∏è Returned ${type} stone to source pool (${sourcePool[type]}/${maxStones})`);
            } else {
                console.log(`‚ö†Ô∏è Cannot return ${type} stone to source pool: already at maximum (${maxStones})`);
            }
        }

        function updateStatus(msg) {
            document.getElementById('status').textContent = msg;
        }

        function clearBoard() {
            if (confirm('Clear all tiles and stones from the board?')) {
                placedTiles.forEach(tile => tile.element.remove());
                placedStones.forEach(stone => stone.element.remove());
                if (playerPosition) playerPosition.element.remove();
                placedTiles = [];
                placedStones = [];
                playerPosition = null;
                updateStatus('Board cleared');
            }
        }

        // Event Handlers - Tile Deck
        deckTileSvg.addEventListener('mousedown', (e) => {
            if (e.button === 2) {
                e.preventDefault();
                isRotatingTile = true;
                rotateTileStartX = e.clientX;
                rotateTileStartRotation = currentRotation;
                return;
            }

            isDraggingTile = true;
            draggedTileId = null;
            draggedTileRotation = currentRotation;
            draggedTileFlipped = currentFlipped;
            draggedTileShrineType = null; // Draw from deck
            const rect = boardSvg.getBoundingClientRect();
            const screenX = e.clientX - rect.left;
            const screenY = e.clientY - rect.top;
            const world = screenToWorld(screenX, screenY);

            ghostTile = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            ghostTile.setAttribute('class', 'ghost-tile');
            ghostTile.setAttribute('transform', `translate(${world.x}, ${world.y})`);
            const tile = createTileGroup(TILE_SIZE, currentRotation, currentFlipped);
            ghostTile.appendChild(tile);
            viewport.appendChild(ghostTile);
        });

        deckTileSvg.addEventListener('contextmenu', (e) => e.preventDefault());

        // Event Handlers - Stone Decks
        ['earth', 'water', 'fire', 'wind', 'void'].forEach(type => {
            document.getElementById(type + '-deck').addEventListener('mousedown', (e) => {
                if (stoneCounts[type] <= 0) return;

                isDraggingStone = true;
                draggedStoneId = null;
                draggedStoneType = type;

                const rect = boardSvg.getBoundingClientRect();
                const screenX = e.clientX - rect.left;
                const screenY = e.clientY - rect.top;
                const world = screenToWorld(screenX, screenY);

                ghostStone = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                ghostStone.setAttribute('class', 'stone stone-ghost');
                ghostStone.setAttribute('transform', `translate(${world.x}, ${world.y})`);

                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', 0);
                circle.setAttribute('cy', 0);
                circle.setAttribute('r', STONE_SIZE);
                circle.setAttribute('class', 'stone-piece');
                circle.setAttribute('fill', STONE_TYPES[type].color);

                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('x', 0);
                text.setAttribute('y', 0);
                text.setAttribute('text-anchor', 'middle');
                text.setAttribute('dominant-baseline', 'middle');
                text.setAttribute('fill', '#fff');
                text.setAttribute('font-size', '14');
                text.setAttribute('font-weight', 'bold');
                text.textContent = STONE_TYPES[type].symbol;

                ghostStone.appendChild(circle);
                ghostStone.appendChild(text);
                viewport.appendChild(ghostStone);
            });
        });

        // Event Handlers - Board
        boardSvg.addEventListener('mousemove', (e) => {
            const rect = boardSvg.getBoundingClientRect();
            const screenX = e.clientX - rect.left;
            const screenY = e.clientY - rect.top;
            const world = screenToWorld(screenX, screenY);

            if (isDraggingTile && ghostTile) {
                const isPlayerTile = (draggedTileShrineType === 'player');
                const snapResult = findNearestSnapPoint(world.x, world.y, isPlayerTile);
                ghostTile.setAttribute('transform', `translate(${snapResult.x}, ${snapResult.y})`);

                if (snapResult.snapped) {
                    snapIndicator.setAttribute('cx', snapResult.x);
                    snapIndicator.setAttribute('cy', snapResult.y);
                    snapIndicator.classList.add('active');
                } else {
                    snapIndicator.classList.remove('active');
                }
            } else if (isDraggingStone && ghostStone) {
                const stonePos = findValidStonePosition(world.x, world.y);
                ghostStone.setAttribute('transform', `translate(${stonePos.x}, ${stonePos.y})`);

                if (stonePos.valid) {
                    snapIndicator.setAttribute('cx', stonePos.x);
                    snapIndicator.setAttribute('cy', stonePos.y);
                    snapIndicator.classList.add('active');
                } else {
                    snapIndicator.classList.remove('active');
                }
            } else if (isDraggingPlayer && ghostPlayer) {
                const playerPos = findNearestHexPosition(world.x, world.y);
                ghostPlayer.setAttribute('transform', `translate(${playerPos.x}, ${playerPos.y})`);

                if (playerPos.valid) {
                    updatePlayerPath(playerPos.x, playerPos.y);

                    const totalCost = calculatePathCost();
                    const moveCheck = canPlayerMoveToHex(playerPos.x, playerPos.y);

                    if (moveCheck.canMove && totalCost <= getTotalAP()) {
                        snapIndicator.setAttribute('cx', playerPos.x);
                        snapIndicator.setAttribute('cy', playerPos.y);
                        snapIndicator.classList.add('active');
                    } else {
                        snapIndicator.classList.remove('active');
                    }

                    // Update status with path cost
                    updateStatus(`Path cost: ${totalCost} AP (${getTotalAP() - totalCost} remaining)`);
                } else {
                    snapIndicator.classList.remove('active');
                }
            }
        });

        document.addEventListener('mouseup', (e) => {
            if (e.button === 0) leftButtonDown = false;
            if (e.button === 2) rightButtonDown = false;

            if (isDraggingTile && ghostTile) {
                const rect = boardSvg.getBoundingClientRect();
                const screenX = e.clientX - rect.left;
                const screenY = e.clientY - rect.top;
                const world = screenToWorld(screenX, screenY);

                const isPlayerTile = (draggedTileShrineType === 'player');
                const snapResult = findNearestSnapPoint(world.x, world.y, isPlayerTile);
                if (snapResult.snapped) {
                    console.log(`üìç Placing tile: rotation=${draggedTileRotation}, flipped=${draggedTileFlipped}, shrine=${draggedTileShrineType}`);
                    const tileId = placeTile(snapResult.x, snapResult.y, draggedTileRotation, draggedTileFlipped, draggedTileShrineType);
                    console.log(`   Tile placed with ID: ${tileId}`);

                    // If this was a player tile from the deck and it was successfully placed
                    if (draggedTileShrineType === 'player' && draggedTileId === null && tileId !== null) {
                        playerTilesAvailable--;
                        document.getElementById('player-tile-count').textContent = playerTilesAvailable;

                        // Remove the first available player tile from the deck visually
                        if (playerTileElements.length > 0) {
                            const tileToRemove = playerTileElements.shift();
                            tileToRemove.remove();
                        }
                    }
                } else if (draggedTileId !== null && draggedTileOriginalPos) {
                    // If this was a placed tile that couldn't be re-placed, restore it to its original position
                    updateStatus('Invalid placement! Tile snapped back to original position.');
                    placeTile(draggedTileOriginalPos.x, draggedTileOriginalPos.y, draggedTileRotation, draggedTileFlipped, draggedTileShrineType);
                } else if (isPlayerTile) {
                    // Player tile couldn't be placed - show why
                    updateStatus('‚ö†Ô∏è Player tiles must touch at least 2 unrevealed tiles!');
                }

                ghostTile.remove();
                ghostTile = null;
                isDraggingTile = false;
                draggedTileId = null;
                draggedTileOriginalPos = null;
                snapIndicator.classList.remove('active');
            } else if (isDraggingStone && ghostStone) {
                const rect = boardSvg.getBoundingClientRect();
                const screenX = e.clientX - rect.left;
                const screenY = e.clientY - rect.top;
                const world = screenToWorld(screenX, screenY);

                const stonePos = findValidStonePosition(world.x, world.y);
                if (stonePos.valid) {
                    placeStone(stonePos.x, stonePos.y, draggedStoneType);
                    if (draggedStoneId === null) {
                        console.log(`üì¶ Placing stone from deck: type=${draggedStoneType}, before=${stoneCounts[draggedStoneType]}`);
                        stoneCounts[draggedStoneType]--;
                        console.log(`üì¶ After decrement: ${draggedStoneType}=${stoneCounts[draggedStoneType]}, playerPool.${draggedStoneType}=${playerPool[draggedStoneType]}`);
                        updateStoneCount(draggedStoneType);
                    }
                    updateStatus('Placed ' + draggedStoneType + ' stone');
                } else {
                    if (draggedStoneId !== null) {
                        // Was a placed stone, couldn't place back
                        returnStoneToPool(draggedStoneType);
                    }
                }

                ghostStone.remove();
                ghostStone = null;
                isDraggingStone = false;
                draggedStoneId = null;
                draggedStoneType = null;
                snapIndicator.classList.remove('active');
            } else if (isDraggingPlayer && ghostPlayer) {
                const rect = boardSvg.getBoundingClientRect();
                const screenX = e.clientX - rect.left;
                const screenY = e.clientY - rect.top;
                const world = screenToWorld(screenX, screenY);

                const playerPos = findNearestHexPosition(world.x, world.y);
                const totalCost = calculatePathCost();
                const startPos = playerPath[0];

                if (playerPos.valid && playerPath.length > 1) {
                    const finalPos = playerPath[playerPath.length - 1];
                    const moveCheck = canPlayerMoveToHex(finalPos.x, finalPos.y, true);

                    // Check if there's a stone at the final position that you CAN'T end turn on
                    const stoneAtFinal = placedStones.find(s => {
                        const dist = Math.sqrt(Math.pow(s.x - finalPos.x, 2) + Math.pow(s.y - finalPos.y, 2));
                        return dist < 5;
                    });

                    // Can't end turn on: earth, wind, water, fire
                    // CAN end turn on: void (or empty hex)
                    const cannotEndTurnHere = stoneAtFinal && stoneAtFinal.type !== 'void';

                    if (cannotEndTurnHere) {
                        console.log(`‚ùå Movement rejected: Cannot end turn on ${stoneAtFinal.type} stone at (${finalPos.x.toFixed(1)}, ${finalPos.y.toFixed(1)})`);
                        placePlayer(startPos.x, startPos.y);
                        updateStatus('Cannot end movement on a ' + stoneAtFinal.type + ' stone!');
                    } else if (moveCheck.canMove && totalCost <= getTotalAP()) {
                        console.log(`‚úÖ Movement successful: ${playerPath.length - 1} hexes, cost ${totalCost} AP`);
                        // Store the last move for undo
                        lastMove = {
                            prevPos: { x: startPos.x, y: startPos.y },
                            newPos: { x: finalPos.x, y: finalPos.y },
                            apCost: totalCost
                        };
                        placePlayer(finalPos.x, finalPos.y);
                        spendAP(totalCost); // Use void AP first, then regular AP

                        // Check if player stepped on a hidden tile - reveal it!
                        // Use the ACTUAL player position after placement
                        const actualPlayerPos = { x: playerPosition.x, y: playerPosition.y };
                        console.log(`üîç Player landed at (${actualPlayerPos.x.toFixed(1)}, ${actualPlayerPos.y.toFixed(1)})`);
                        console.log(`   finalPos from path: (${finalPos.x.toFixed(1)}, ${finalPos.y.toFixed(1)})`);

                        // Use getAllHexagonPositions which properly handles trapezoids
                        const allHexes = getAllHexagonPositions();
                        
                        // Find the hex position where the player landed
                        let playerHex = null;
                        let minDist = Infinity;
                        allHexes.forEach(hexPos => {
                            const dist = Math.sqrt(Math.pow(hexPos.x - actualPlayerPos.x, 2) + Math.pow(hexPos.y - actualPlayerPos.y, 2));
                            if (dist < minDist) {
                                minDist = dist;
                                playerHex = hexPos;
                            }
                        });

                        if (playerHex && minDist < 5 && playerHex.tiles) {
                            console.log(`   Player is on hex at (${playerHex.x.toFixed(1)}, ${playerHex.y.toFixed(1)}), dist=${minDist.toFixed(2)}`);
                            console.log(`   This hex is contributed to by ${playerHex.tiles.length} tile(s)`);
                            
                            // Find flipped tiles that contribute to this hex position
                            const flippedTiles = playerHex.tiles.filter(t => t.flipped && !t.isPlayerTile);
                            
                            if (flippedTiles.length > 0) {
                                // If multiple flipped tiles share this hex, choose the one whose center is closest to player
                                let tileToReveal = flippedTiles[0];
                                if (flippedTiles.length > 1) {
                                    let minTileDist = Infinity;
                                    flippedTiles.forEach(tile => {
                                        const tileDist = Math.sqrt(Math.pow(tile.x - actualPlayerPos.x, 2) + Math.pow(tile.y - actualPlayerPos.y, 2));
                                        console.log(`     Flipped tile at (${tile.x.toFixed(1)}, ${tile.y.toFixed(1)}): dist to center=${tileDist.toFixed(1)}`);
                                        if (tileDist < minTileDist) {
                                            minTileDist = tileDist;
                                            tileToReveal = tile;
                                        }
                                    });
                                    console.log(`   Multiple flipped tiles - choosing closest at (${tileToReveal.x.toFixed(1)}, ${tileToReveal.y.toFixed(1)})`);
                                }
                                console.log(`‚ú® Revealing tile at (${tileToReveal.x.toFixed(1)}, ${tileToReveal.y.toFixed(1)})`);
                                revealTile(tileToReveal.id);
                            } else {
                                console.log(`   No flipped tiles at this hex position`);
                                updateStatus(`Moved ${playerPath.length - 1} hexes (cost: ${totalCost} AP, ${getTotalAP()} AP remaining)`);
                            }
                        } else {
                            console.log(`   ‚ùå Player not on any valid hex (minDist=${minDist.toFixed(2)})`);
                            updateStatus(`Moved ${playerPath.length - 1} hexes (cost: ${totalCost} AP, ${getTotalAP()} AP remaining)`);
                        }
                    } else if (!moveCheck.canMove) {
                        console.log(`‚ùå Movement rejected: Path blocked at (${finalPos.x.toFixed(1)}, ${finalPos.y.toFixed(1)})`);
                        placePlayer(startPos.x, startPos.y);
                        updateStatus('Cannot move there!');
                    } else {
                        console.log(`‚ùå Movement rejected: Insufficient AP (need ${totalCost}, have ${getTotalAP()})`);
                        placePlayer(startPos.x, startPos.y);
                        updateStatus(`Not enough AP! (need ${totalCost}, have ${getTotalAP()})`);
                    }
                } else {
                    placePlayer(startPos.x, startPos.y);
                }

                ghostPlayer.remove();
                ghostPlayer = null;
                if (pathLine) {
                    pathLine.remove();
                    pathLine = null;
                }
                // Clean up path labels
                pathCostLabels.forEach(label => label.remove());
                pathCostLabels = [];
                playerPath = [];
                isDraggingPlayer = false;
                snapIndicator.classList.remove('active');
            }

            if (isPanning) {
                isPanning = false;
                boardSvg.style.cursor = 'grab';
            }
            if (isRotatingBoard) {
                isRotatingBoard = false;
                boardSvg.style.cursor = 'grab';
            }
            if (isRotatingTile) {
                isRotatingTile = false;
            }
        });

        // Clean up ghost when mouse leaves the board
        boardSvg.addEventListener('mouseleave', () => {
            snapIndicator.classList.remove('active');
        });

        boardSvg.addEventListener('mousedown', (e) => {
            console.log(`üñ±Ô∏è boardSvg mousedown: button=${e.button}, shift=${e.shiftKey}, target=${e.target.tagName}`);
            
            if (e.button === 0) leftButtonDown = true;
            if (e.button === 2) rightButtonDown = true;

            // SHIFT+CLICK: Debug mode - pin hex coordinates
            if (e.shiftKey && e.button === 0) {
                console.log(`üîç SHIFT+CLICK DETECTED!`);
                e.preventDefault();
                e.stopPropagation();
                const rect = boardSvg.getBoundingClientRect();
                const screenX = e.clientX - rect.left;
                const screenY = e.clientY - rect.top;
                const world = screenToWorld(screenX, screenY);
                
                console.log(`üìç DEBUG: Shift+Click at screen (${screenX.toFixed(1)}, ${screenY.toFixed(1)})`);
                console.log(`   World coordinates: (${world.x.toFixed(1)}, ${world.y.toFixed(1)})`);
                
                // Find nearest hex position
                const hexPos = findNearestHexPosition(world.x, world.y);
                if (hexPos.valid) {
                    console.log(`   Nearest hex: (${hexPos.x.toFixed(1)}, ${hexPos.y.toFixed(1)})`);
                    
                    // Find all hexagon positions to see which tiles contribute
                    const allHexes = getAllHexagonPositions();
                    const matchingHex = allHexes.find(h => {
                        const dist = Math.sqrt(Math.pow(h.x - hexPos.x, 2) + Math.pow(h.y - hexPos.y, 2));
                        return dist < 5;
                    });
                    
                    if (matchingHex && matchingHex.tiles) {
                        console.log(`   This hex is contributed by ${matchingHex.tiles.length} tile(s):`);
                        matchingHex.tiles.forEach((tile, i) => {
                            console.log(`     [${i}] Tile at (${tile.x.toFixed(1)}, ${tile.y.toFixed(1)}): flipped=${tile.flipped}, shrine=${tile.shrineType}, id=${tile.id}`);
                        });
                    }
                }
                
                // Create visual debug marker
                const marker = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                marker.setAttribute('class', 'debug-marker');
                marker.setAttribute('transform', `translate(${world.x}, ${world.y})`);
                
                // Draw crosshair
                const line1 = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line1.setAttribute('x1', '-10');
                line1.setAttribute('y1', '0');
                line1.setAttribute('x2', '10');
                line1.setAttribute('y2', '0');
                line1.setAttribute('stroke', '#ff00ff');
                line1.setAttribute('stroke-width', '2');
                marker.appendChild(line1);
                
                const line2 = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line2.setAttribute('x1', '0');
                line2.setAttribute('y1', '-10');
                line2.setAttribute('x2', '0');
                line2.setAttribute('y2', '10');
                line2.setAttribute('stroke', '#ff00ff');
                line2.setAttribute('stroke-width', '2');
                marker.appendChild(line2);
                
                // Draw circle
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', '0');
                circle.setAttribute('cy', '0');
                circle.setAttribute('r', '5');
                circle.setAttribute('fill', 'none');
                circle.setAttribute('stroke', '#ff00ff');
                circle.setAttribute('stroke-width', '2');
                marker.appendChild(circle);
                
                // Add text label
                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('x', '12');
                text.setAttribute('y', '5');
                text.setAttribute('fill', '#ff00ff');
                text.setAttribute('font-size', '10');
                text.setAttribute('font-weight', 'bold');
                text.textContent = `(${world.x.toFixed(0)}, ${world.y.toFixed(0)})`;
                marker.appendChild(text);
                
                viewport.appendChild(marker);
                debugMarkers.push(marker);
                
                updateStatus(`DEBUG: Pinned (${world.x.toFixed(1)}, ${world.y.toFixed(1)}) - Check console for details`);
                return; // Don't start panning
            }

            // Don't start panning if we're already dragging something
            if (isDraggingTile || isDraggingStone || isDraggingPlayer) return;

            const targetClass = e.target.getAttribute('class');
            const isStone = targetClass && (targetClass.includes('stone') || e.target.closest('.stone'));
            const isPlayer = targetClass && (targetClass.includes('player') || e.target.closest('.player'));

            if (e.button === 0 && (e.target === boardSvg || e.target === viewport || e.target.tagName === 'polygon') && !isStone && !isPlayer) {
                e.preventDefault();
                isPanning = true;
                panStartX = e.clientX;
                panStartY = e.clientY;
                lastPanX = viewportX;
                lastPanY = viewportY;
                boardSvg.style.cursor = 'grabbing';
            } else if (e.button === 2 && (e.target === boardSvg || e.target === viewport)) {
                e.preventDefault();
                isRotatingBoard = true;
                rotateStartX = e.clientX;
                rotateStartRotation = viewportRotation;
                boardSvg.style.cursor = 'grabbing';
            }
        });

        boardSvg.addEventListener('contextmenu', (e) => e.preventDefault());

        document.addEventListener('mousemove', (e) => {
            if (isPanning) {
                const dx = e.clientX - panStartX;
                const dy = e.clientY - panStartY;
                const rad = -viewportRotation * Math.PI / 180;
                const cos = Math.cos(rad);
                const sin = Math.sin(rad);
                const rotatedDx = dx * cos - dy * sin;
                const rotatedDy = dx * sin + dy * cos;
                viewportX = lastPanX + rotatedDx;
                viewportY = lastPanY + rotatedDy;
                updateViewport();
            } else if (isRotatingBoard) {
                const dx = e.clientX - rotateStartX;
                viewportRotation = rotateStartRotation + (dx / 100) * 90;
                updateViewport();
            } else if (isRotatingTile) {
                const dx = e.clientX - rotateTileStartX;
                const steps = Math.round(dx / 60);
                currentRotation = (rotateTileStartRotation - steps + 6) % 6; // Reversed direction: subtract instead of add
                drawDeckTile();
            }
        });

        // Debug mode: array to store debug markers
        let debugMarkers = [];

        document.addEventListener('keydown', (e) => {
            console.log(`Key pressed: ${e.key}, isDraggingTile=${isDraggingTile}, ghostTile=${!!ghostTile}, shift=${e.shiftKey}`);
            if (e.key === 'f' || e.key === 'F') {
                console.log(`F key detected! isDraggingTile=${isDraggingTile}, ghostTile exists=${!!ghostTile}, shift=${e.shiftKey}`);
                
                // SHIFT+F: Debug mode - show tile coordinates
                if (e.shiftKey && isDraggingTile && ghostTile) {
                    console.log(`üîç DEBUG: Tile being dragged`);
                    console.log(`   draggedTileId: ${draggedTileId}`);
                    console.log(`   draggedTileShrineType: ${draggedTileShrineType}`);
                    console.log(`   draggedTileFlipped: ${draggedTileFlipped}`);
                    console.log(`   draggedTileRotation: ${draggedTileRotation}`);
                    if (draggedTileOriginalPos) {
                        console.log(`   Original position: (${draggedTileOriginalPos.x.toFixed(1)}, ${draggedTileOriginalPos.y.toFixed(1)})`);
                    }
                    
                    // Get current ghost position
                    const transform = ghostTile.getAttribute('transform');
                    console.log(`   Current ghost transform: ${transform}`);
                    
                    updateStatus(`DEBUG: Tile ID=${draggedTileId}, shrine=${draggedTileShrineType}, flipped=${draggedTileFlipped}`);
                }
                // Normal F: Flip the tile
                else if (!e.shiftKey && isDraggingTile && ghostTile) {
                    console.log(`Before flip: draggedTileFlipped=${draggedTileFlipped}`);
                    // Flip the tile being dragged
                    draggedTileFlipped = !draggedTileFlipped;
                    console.log(`After flip: draggedTileFlipped=${draggedTileFlipped}`);

                    // Update the ghost tile visual
                    ghostTile.innerHTML = '';
                    const tile = createTileGroup(TILE_SIZE, draggedTileRotation, draggedTileFlipped);
                    ghostTile.appendChild(tile);

                    updateStatus(`Tile ${draggedTileFlipped ? 'flipped' : 'unflipped'}`);
                    console.log(`Tile visual updated`);
                } else {
                    console.log(`Cannot flip - not dragging a tile or no ghost tile`);
                }
            }
        });

        boardSvg.addEventListener('wheel', (e) => {
            e.preventDefault();
            const rect = boardSvg.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            const worldBefore = screenToWorld(mouseX, mouseY);
            const zoomFactor = e.deltaY < 0 ? 1.1 : 0.9;
            viewportScale = Math.max(0.1, Math.min(10, viewportScale * zoomFactor));
            const worldAfter = screenToWorld(mouseX, mouseY);
            viewportX += (worldAfter.x - worldBefore.x) * viewportScale;
            viewportY += (worldAfter.y - worldBefore.y) * viewportScale;
            updateViewport();
        });

        document.getElementById('end-turn').onclick = function() {
            // Check if current player is on a shrine
            if (playerPosition) {
                const shrine = findShrineAtPosition(playerPosition.x, playerPosition.y);
                if (shrine && shrine.shrineType !== 'catacomb') {
                    // Regular shrine - replenish stones (catacomb doesn't replenish)
                    replenishShrineStones(shrine.shrineType);
                }
            }

            currentAP = 5;
            document.getElementById('ap-count').textContent = currentAP;
            updateVoidAP(); // Update void AP to match current void stones
            lastMove = null; // Clear undo history on new turn

            // Switch to next player based on color rank
            if (playerPositions.length > 1) {
                // Color rank order: void(1) -> wind(2) -> fire(3) -> water(4) -> earth(5)
                const COLOR_RANK = {
                    '#9458f4': 1, // purple/void
                    '#ffce00': 2, // yellow/wind
                    '#ed1b43': 3, // red/fire
                    '#5894f4': 4, // blue/water
                    '#69d83a': 5  // green/earth
                };

                // Sort players by rank
                const sortedPlayers = [...playerPositions].map((p, idx) => ({
                    index: idx,
                    rank: COLOR_RANK[p.color] || 999
                })).sort((a, b) => a.rank - b.rank);

                // Find current player in sorted list
                const currentSortedIndex = sortedPlayers.findIndex(p => p.index === activePlayerIndex);
                
                // Move to next player in sorted order (wrap around)
                const nextSortedIndex = (currentSortedIndex + 1) % sortedPlayers.length;
                activePlayerIndex = sortedPlayers[nextSortedIndex].index;

                const colorNames = {
                    '#9458f4': 'Purple (Void)',
                    '#ffce00': 'Yellow (Wind)',
                    '#ed1b43': 'Red (Fire)',
                    '#5894f4': 'Blue (Water)',
                    '#69d83a': 'Green (Earth)'
                };

                const nextPlayer = playerPositions[activePlayerIndex];
                
                // Update UI to show new player's inventory
                Object.keys(stoneCounts).forEach(updateStoneCount);
                spellSystem.updateScrollCount();
                
                updateStatus(`Turn ended. Now ${colorNames[nextPlayer.color]}'s turn! AP restored.`);
                console.log(`üîÑ Switched to player ${activePlayerIndex + 1} (${colorNames[nextPlayer.color]})`);
            } else {
                updateStatus('Turn ended. AP restored.');
            }
        };

        document.getElementById('undo-move').onclick = function() {
            if (!lastMove) {
                updateStatus('No move to undo!');
                return;
            }

            // Restore previous position
            placePlayer(lastMove.prevPos.x, lastMove.prevPos.y);

            // Restore AP
            currentAP += lastMove.apCost;
            document.getElementById('ap-count').textContent = currentAP;

            updateStatus(`Undid movement. Restored ${lastMove.apCost} AP (now ${currentAP} AP).`);

            // Clear the undo history (can only undo once)
            lastMove = null;
        };

        document.getElementById('scroll-inventory').onclick = function() {
            spellSystem.showInventory();
        };

        document.getElementById('cast-spell').onclick = function() {
            spellSystem.castSpell();
        };

        function findShrineAtPosition(x, y) {
            // Check each tile to see if player is on the center hex (shrine location)
            for (const tile of placedTiles) {
                const dist = Math.sqrt(Math.pow(tile.x - x, 2) + Math.pow(tile.y - y, 2));
                // Center hex is at the tile's position (0,0 offset)
                if (dist < 5) {
                    return tile;
                }
            }
            return null;
        }

        function replenishShrineStones(shrineType) {
            // Stone rank determines replenishment amount
            const STONE_RANK = {
                'void': 1,
                'wind': 2,
                'fire': 3,
                'water': 4,
                'earth': 5
            };

            const replenishAmount = STONE_RANK[shrineType];

            // Calculate how many stones we can actually transfer
            // Limited by: source pool availability, player pool capacity, and replenish amount
            const availableInSource = sourcePool[shrineType];
            const spaceInPlayer = playerPoolCapacity[shrineType] - playerPool[shrineType];
            const actualReplenished = Math.min(replenishAmount, availableInSource, spaceInPlayer);

            if (actualReplenished > 0) {
                // Transfer from source pool to player pool
                sourcePool[shrineType] -= actualReplenished;
                playerPool[shrineType] += actualReplenished;
                updateStoneCount(shrineType);

                updateStatus(`Shrine activated! Transferred ${actualReplenished} ${shrineType} stone${actualReplenished > 1 ? 's' : ''} from source to player pool. (Source: ${sourcePool[shrineType]}/${sourcePoolCapacity[shrineType]}, Player: ${playerPool[shrineType]}/${playerPoolCapacity[shrineType]}). AP restored.`);
            } else if (spaceInPlayer === 0) {
                updateStatus(`Shrine activated but player pool is full! (${playerPool[shrineType]}/${playerPoolCapacity[shrineType]}). AP restored.`);
            } else if (availableInSource === 0) {
                updateStatus(`Shrine activated but source pool is empty! (${sourcePool[shrineType]}/${sourcePoolCapacity[shrineType]}). AP restored.`);
            }
        }

        let activeTeleportIndicators = [];

        function updateCatacombIndicators() {
            // Remove existing indicators
            activeTeleportIndicators.forEach(ind => ind.remove());
            activeTeleportIndicators = [];

            // Check if player is on a catacomb shrine
            if (!playerPosition) return;

            const currentShrine = findShrineAtPosition(playerPosition.x, playerPosition.y);
            if (!currentShrine || currentShrine.shrineType !== 'catacomb') return;

            // Find all other REVEALED catacomb shrines (not flipped) WITHOUT stones on them
            const otherCatacombs = placedTiles.filter(tile => {
                if (tile.shrineType !== 'catacomb') return false;
                if (tile.flipped) return false; // Only revealed catacombs
                if (Math.abs(tile.x - currentShrine.x) <= 5 && Math.abs(tile.y - currentShrine.y) <= 5) return false; // Same catacomb
                
                // Check if there's a stone at the catacomb center
                const hasStone = placedStones.some(stone => {
                    const dist = Math.sqrt(Math.pow(stone.x - tile.x, 2) + Math.pow(stone.y - tile.y, 2));
                    return dist < 5; // Stone is at the center of this catacomb
                });
                
                return !hasStone; // Only allow teleport to catacombs without stones
            });

            if (otherCatacombs.length === 0) {
                updateStatus('‚ö∞ Standing on catacomb shrine, but no valid destinations! (catacombs must be revealed and have no stone on center)');
                return;
            }

            // Create visual indicators for teleport destinations
            otherCatacombs.forEach(shrine => {
                const indicator = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                indicator.setAttribute('cx', shrine.x);
                indicator.setAttribute('cy', shrine.y);
                indicator.setAttribute('r', '15');
                indicator.setAttribute('fill', '#8b4513');
                indicator.setAttribute('opacity', '0.5');
                indicator.setAttribute('stroke', '#fff');
                indicator.setAttribute('stroke-width', '2');
                indicator.setAttribute('class', 'teleport-indicator');
                indicator.style.cursor = 'pointer';
                indicator.style.animation = 'pulse 1s infinite';

                // Add click handler for teleportation
                indicator.addEventListener('click', (e) => {
                    e.stopPropagation();
                    e.preventDefault();

                    // Double-check no stone was placed since indicators were created
                    const hasStoneNow = placedStones.some(stone => {
                        const dist = Math.sqrt(Math.pow(stone.x - shrine.x, 2) + Math.pow(stone.y - shrine.y, 2));
                        return dist < 5;
                    });
                    
                    if (hasStoneNow) {
                        updateStatus('‚ö∞ Cannot teleport there - a stone is blocking the catacomb!');
                        updateCatacombIndicators(); // Refresh indicators
                        return;
                    }

                    // Teleport player (no AP cost)
                    placePlayer(shrine.x, shrine.y);
                    updateStatus(`‚ö∞ Teleported to another catacomb shrine!`);

                    // Update indicators for new position
                    updateCatacombIndicators();
                });

                viewport.appendChild(indicator);
                activeTeleportIndicators.push(indicator);
            });

            updateStatus(`‚ö∞ Standing on catacomb shrine. Click on another revealed catacomb (glowing circles) to teleport there (free).`);
        }

        // Generate spiral tile positions starting from center
        // Based on the spiral pattern from the image: 1(center), 2(SE), 3(SW), 4(W), 5(NW), 6(NE), 7(E), then ring 2...
        function generateSpiralPositions(numTiles) {
            const positions = [];
            const largeHexSize = TILE_SIZE * 4; // Grid size for tile snapping

            // Predefined spiral path in axial coordinates (q, r)
            // 6 tiles per player (one of each shrine type)
            const spiralPath = [
                { q: 0, r: 0 },    // 1 - Center
                { q: 0, r: 1 },    // 2 - SE
                { q: -1, r: 1 },   // 3 - SW
                { q: -1, r: 0 },   // 4 - W
                { q: 0, r: -1 },   // 5 - NW
                { q: 1, r: -1 },   // 6 - NE (1 player complete - 6 tiles)
                { q: 1, r: 0 },    // 7 - E
                { q: 1, r: 1 },    // 8 - SE (ring 2)
                { q: 0, r: 2 },    // 9
                { q: -1, r: 2 },   // 10
                { q: -2, r: 2 },   // 11
                { q: -2, r: 1 },   // 12 (2 players complete - 12 tiles)
                { q: -2, r: 0 },   // 13
                { q: -1, r: -1 },  // 14
                { q: 0, r: -2 },   // 15
                { q: 1, r: -2 },   // 16
                { q: 2, r: -2 },   // 17
                { q: 2, r: -1 },   // 18 (3 players complete - 18 tiles)
                { q: 2, r: 0 },    // 19
                { q: 2, r: 1 },    // 20
                { q: 1, r: 2 },    // 21 (ring 3)
                { q: 0, r: 3 },    // 22
                { q: -1, r: 3 },   // 23
                { q: -2, r: 3 },   // 24 (4 players complete - 24 tiles)
                { q: -3, r: 3 },   // 25
                { q: -3, r: 2 },   // 26
                { q: -3, r: 1 },   // 27
                { q: -3, r: 0 },   // 28
                { q: -2, r: -1 },  // 29
                { q: -1, r: -2 },  // 30 (5 players complete - 30 tiles)
                { q: 0, r: -3 },   // 31 (extra positions for future)
                { q: 1, r: -3 },   // 32
                { q: 2, r: -3 },   // 33
                { q: 3, r: -3 },   // 34
                { q: 3, r: -2 },   // 35
                { q: 3, r: -1 },   // 36
            ];

            // Convert to pixel positions
            for (let i = 0; i < Math.min(numTiles, spiralPath.length); i++) {
                const pos = hexToPixel(spiralPath[i].q, spiralPath[i].r, largeHexSize);
                positions.push({ x: pos.x, y: pos.y });
            }

            return positions;
        }


        // Start game with selected number of players
        function startGame(numPlayers) {
            // Clear the board first
            clearBoard();

            // Reset color assignments for this game
            gameSessionColors.clear();
            playerColor = null;
            console.log(`üé® Starting game with ${numPlayers} player(s). Colors will be assigned as player tiles are placed.`);

            // Hide player selection menu
            document.getElementById('player-selection').style.display = 'none';
            document.querySelector('.game-container').style.display = 'flex';

            // Calculate number of tiles (6 per player)
            const numTiles = numPlayers * 6;

            // Initialize
            initializeDeck(numPlayers); // Shuffle the tile deck
            initializePlayerTiles(numPlayers); // Create player tiles
            Object.keys(stoneCounts).forEach(updateStoneCount);
            updateVoidAP(); // Initialize void AP display
            drawDeckTile();
            updateViewport();
            boardSvg.style.cursor = 'grab';

            // Place hidden tiles in spiral pattern
            const spiralPositions = generateSpiralPositions(numTiles);
            console.log(`Placing ${numTiles} tiles for ${numPlayers} player(s)`);
            spiralPositions.forEach((pos, index) => {
                console.log(`Tile ${index + 1}: (${pos.x.toFixed(1)}, ${pos.y.toFixed(1)})`);
                placeTile(pos.x, pos.y, 0, true); // Place as flipped (hidden)
            });

            updateStatus(`Game started with ${numPlayers} player(s) (${numTiles} tiles). Drag a player tile from the Player Tiles deck to start.`);
        }
    </script>
</body>
</html>
